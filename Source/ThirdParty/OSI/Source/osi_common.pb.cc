// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osi_common.proto

#include "osi_common.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace osi3 {
PROTOBUF_CONSTEXPR Vector3d::Vector3d(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0} {}
struct Vector3dDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vector3dDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vector3dDefaultTypeInternal() {}
  union {
    Vector3d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vector3dDefaultTypeInternal _Vector3d_default_instance_;
PROTOBUF_CONSTEXPR Vector2d::Vector2d(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct Vector2dDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vector2dDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vector2dDefaultTypeInternal() {}
  union {
    Vector2d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vector2dDefaultTypeInternal _Vector2d_default_instance_;
PROTOBUF_CONSTEXPR Timestamp::Timestamp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seconds_)*/int64_t{0}
  , /*decltype(_impl_.nanos_)*/0u} {}
struct TimestampDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimestampDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimestampDefaultTypeInternal() {}
  union {
    Timestamp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampDefaultTypeInternal _Timestamp_default_instance_;
PROTOBUF_CONSTEXPR Dimension3d::Dimension3d(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.length_)*/0
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0} {}
struct Dimension3dDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Dimension3dDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Dimension3dDefaultTypeInternal() {}
  union {
    Dimension3d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Dimension3dDefaultTypeInternal _Dimension3d_default_instance_;
PROTOBUF_CONSTEXPR Orientation3d::Orientation3d(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.roll_)*/0
  , /*decltype(_impl_.pitch_)*/0
  , /*decltype(_impl_.yaw_)*/0} {}
struct Orientation3dDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Orientation3dDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Orientation3dDefaultTypeInternal() {}
  union {
    Orientation3d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Orientation3dDefaultTypeInternal _Orientation3d_default_instance_;
PROTOBUF_CONSTEXPR Identifier::Identifier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/uint64_t{0u}} {}
struct IdentifierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IdentifierDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IdentifierDefaultTypeInternal() {}
  union {
    Identifier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IdentifierDefaultTypeInternal _Identifier_default_instance_;
PROTOBUF_CONSTEXPR ExternalReference::ExternalReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.identifier_)*/{}
  , /*decltype(_impl_.reference_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ExternalReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExternalReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExternalReferenceDefaultTypeInternal() {}
  union {
    ExternalReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExternalReferenceDefaultTypeInternal _ExternalReference_default_instance_;
PROTOBUF_CONSTEXPR MountingPosition::MountingPosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.orientation_)*/nullptr} {}
struct MountingPositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MountingPositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MountingPositionDefaultTypeInternal() {}
  union {
    MountingPosition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MountingPositionDefaultTypeInternal _MountingPosition_default_instance_;
PROTOBUF_CONSTEXPR Spherical3d::Spherical3d(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.distance_)*/0
  , /*decltype(_impl_.azimuth_)*/0
  , /*decltype(_impl_.elevation_)*/0} {}
struct Spherical3dDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Spherical3dDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Spherical3dDefaultTypeInternal() {}
  union {
    Spherical3d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Spherical3dDefaultTypeInternal _Spherical3d_default_instance_;
PROTOBUF_CONSTEXPR LogicalLaneAssignment::LogicalLaneAssignment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.assigned_lane_id_)*/nullptr
  , /*decltype(_impl_.s_position_)*/0
  , /*decltype(_impl_.t_position_)*/0
  , /*decltype(_impl_.angle_to_lane_)*/0} {}
struct LogicalLaneAssignmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalLaneAssignmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalLaneAssignmentDefaultTypeInternal() {}
  union {
    LogicalLaneAssignment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalLaneAssignmentDefaultTypeInternal _LogicalLaneAssignment_default_instance_;
PROTOBUF_CONSTEXPR BaseStationary::BaseStationary(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_polygon_)*/{}
  , /*decltype(_impl_.dimension_)*/nullptr
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.orientation_)*/nullptr} {}
struct BaseStationaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BaseStationaryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BaseStationaryDefaultTypeInternal() {}
  union {
    BaseStationary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BaseStationaryDefaultTypeInternal _BaseStationary_default_instance_;
PROTOBUF_CONSTEXPR BaseMoving::BaseMoving(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_polygon_)*/{}
  , /*decltype(_impl_.dimension_)*/nullptr
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.orientation_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.acceleration_)*/nullptr
  , /*decltype(_impl_.orientation_rate_)*/nullptr
  , /*decltype(_impl_.orientation_acceleration_)*/nullptr} {}
struct BaseMovingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BaseMovingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BaseMovingDefaultTypeInternal() {}
  union {
    BaseMoving _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BaseMovingDefaultTypeInternal _BaseMoving_default_instance_;
PROTOBUF_CONSTEXPR StatePoint::StatePoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.orientation_)*/nullptr} {}
struct StatePointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatePointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatePointDefaultTypeInternal() {}
  union {
    StatePoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatePointDefaultTypeInternal _StatePoint_default_instance_;
PROTOBUF_CONSTEXPR WavelengthData::WavelengthData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_)*/0
  , /*decltype(_impl_.end_)*/0
  , /*decltype(_impl_.samples_number_)*/0} {}
struct WavelengthDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WavelengthDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WavelengthDataDefaultTypeInternal() {}
  union {
    WavelengthData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WavelengthDataDefaultTypeInternal _WavelengthData_default_instance_;
PROTOBUF_CONSTEXPR SpatialSignalStrength::SpatialSignalStrength(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.horizontal_angle_)*/0
  , /*decltype(_impl_.vertical_angle_)*/0
  , /*decltype(_impl_.signal_strength_)*/0} {}
struct SpatialSignalStrengthDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpatialSignalStrengthDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpatialSignalStrengthDefaultTypeInternal() {}
  union {
    SpatialSignalStrength _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpatialSignalStrengthDefaultTypeInternal _SpatialSignalStrength_default_instance_;
PROTOBUF_CONSTEXPR ColorDescription::ColorDescription(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.grey_)*/nullptr
  , /*decltype(_impl_.rgb_)*/nullptr
  , /*decltype(_impl_.rgbir_)*/nullptr
  , /*decltype(_impl_.hsv_)*/nullptr
  , /*decltype(_impl_.luv_)*/nullptr
  , /*decltype(_impl_.cmyk_)*/nullptr} {}
struct ColorDescriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColorDescriptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColorDescriptionDefaultTypeInternal() {}
  union {
    ColorDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColorDescriptionDefaultTypeInternal _ColorDescription_default_instance_;
PROTOBUF_CONSTEXPR ColorGrey::ColorGrey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.grey_)*/0} {}
struct ColorGreyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColorGreyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColorGreyDefaultTypeInternal() {}
  union {
    ColorGrey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColorGreyDefaultTypeInternal _ColorGrey_default_instance_;
PROTOBUF_CONSTEXPR ColorRGB::ColorRGB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.red_)*/0
  , /*decltype(_impl_.green_)*/0
  , /*decltype(_impl_.blue_)*/0} {}
struct ColorRGBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColorRGBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColorRGBDefaultTypeInternal() {}
  union {
    ColorRGB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColorRGBDefaultTypeInternal _ColorRGB_default_instance_;
PROTOBUF_CONSTEXPR ColorRGBIR::ColorRGBIR(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.red_)*/0
  , /*decltype(_impl_.green_)*/0
  , /*decltype(_impl_.blue_)*/0
  , /*decltype(_impl_.infrared_)*/0} {}
struct ColorRGBIRDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColorRGBIRDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColorRGBIRDefaultTypeInternal() {}
  union {
    ColorRGBIR _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColorRGBIRDefaultTypeInternal _ColorRGBIR_default_instance_;
PROTOBUF_CONSTEXPR ColorHSV::ColorHSV(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hue_)*/0
  , /*decltype(_impl_.saturation_)*/0
  , /*decltype(_impl_.value_)*/0} {}
struct ColorHSVDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColorHSVDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColorHSVDefaultTypeInternal() {}
  union {
    ColorHSV _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColorHSVDefaultTypeInternal _ColorHSV_default_instance_;
PROTOBUF_CONSTEXPR ColorLUV::ColorLUV(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.luminance_)*/0
  , /*decltype(_impl_.u_)*/0
  , /*decltype(_impl_.v_)*/0} {}
struct ColorLUVDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColorLUVDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColorLUVDefaultTypeInternal() {}
  union {
    ColorLUV _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColorLUVDefaultTypeInternal _ColorLUV_default_instance_;
PROTOBUF_CONSTEXPR ColorCMYK::ColorCMYK(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cyan_)*/0
  , /*decltype(_impl_.magenta_)*/0
  , /*decltype(_impl_.yellow_)*/0
  , /*decltype(_impl_.key_)*/0} {}
struct ColorCMYKDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColorCMYKDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColorCMYKDefaultTypeInternal() {}
  union {
    ColorCMYK _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColorCMYKDefaultTypeInternal _ColorCMYK_default_instance_;
PROTOBUF_CONSTEXPR Pedalry::Pedalry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pedal_position_acceleration_)*/0
  , /*decltype(_impl_.pedal_position_brake_)*/0
  , /*decltype(_impl_.pedal_position_clutch_)*/0} {}
struct PedalryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PedalryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PedalryDefaultTypeInternal() {}
  union {
    Pedalry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PedalryDefaultTypeInternal _Pedalry_default_instance_;
PROTOBUF_CONSTEXPR VehicleSteeringWheel::VehicleSteeringWheel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.angle_)*/0
  , /*decltype(_impl_.angular_speed_)*/0
  , /*decltype(_impl_.torque_)*/0} {}
struct VehicleSteeringWheelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VehicleSteeringWheelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VehicleSteeringWheelDefaultTypeInternal() {}
  union {
    VehicleSteeringWheel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VehicleSteeringWheelDefaultTypeInternal _VehicleSteeringWheel_default_instance_;
PROTOBUF_CONSTEXPR GeodeticPosition::GeodeticPosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.longitude_)*/0
  , /*decltype(_impl_.latitude_)*/0
  , /*decltype(_impl_.altitude_)*/0} {}
struct GeodeticPositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeodeticPositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeodeticPositionDefaultTypeInternal() {}
  union {
    GeodeticPosition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeodeticPositionDefaultTypeInternal _GeodeticPosition_default_instance_;
PROTOBUF_CONSTEXPR KeyValuePair::KeyValuePair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct KeyValuePairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyValuePairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyValuePairDefaultTypeInternal() {}
  union {
    KeyValuePair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyValuePairDefaultTypeInternal _KeyValuePair_default_instance_;
}  // namespace osi3
static ::_pb::Metadata file_level_metadata_osi_5fcommon_2eproto[26];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_osi_5fcommon_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_osi_5fcommon_2eproto = nullptr;

const uint32_t TableStruct_osi_5fcommon_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::osi3::Vector3d, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::Vector3d, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::Vector3d, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::osi3::Vector3d, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::osi3::Vector3d, _impl_.z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::Vector2d, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::Vector2d, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::Vector2d, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::osi3::Vector2d, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::osi3::Timestamp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::Timestamp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::Timestamp, _impl_.seconds_),
  PROTOBUF_FIELD_OFFSET(::osi3::Timestamp, _impl_.nanos_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::osi3::Dimension3d, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::Dimension3d, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::Dimension3d, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::osi3::Dimension3d, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::osi3::Dimension3d, _impl_.height_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::Orientation3d, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::Orientation3d, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::Orientation3d, _impl_.roll_),
  PROTOBUF_FIELD_OFFSET(::osi3::Orientation3d, _impl_.pitch_),
  PROTOBUF_FIELD_OFFSET(::osi3::Orientation3d, _impl_.yaw_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::Identifier, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::Identifier, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::Identifier, _impl_.value_),
  0,
  PROTOBUF_FIELD_OFFSET(::osi3::ExternalReference, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::ExternalReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::ExternalReference, _impl_.reference_),
  PROTOBUF_FIELD_OFFSET(::osi3::ExternalReference, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::osi3::ExternalReference, _impl_.identifier_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::MountingPosition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::MountingPosition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::MountingPosition, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::osi3::MountingPosition, _impl_.orientation_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::osi3::Spherical3d, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::Spherical3d, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::Spherical3d, _impl_.distance_),
  PROTOBUF_FIELD_OFFSET(::osi3::Spherical3d, _impl_.azimuth_),
  PROTOBUF_FIELD_OFFSET(::osi3::Spherical3d, _impl_.elevation_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneAssignment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneAssignment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneAssignment, _impl_.assigned_lane_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneAssignment, _impl_.s_position_),
  PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneAssignment, _impl_.t_position_),
  PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneAssignment, _impl_.angle_to_lane_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::osi3::BaseStationary, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseStationary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::BaseStationary, _impl_.dimension_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseStationary, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseStationary, _impl_.orientation_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseStationary, _impl_.base_polygon_),
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::BaseMoving, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseMoving, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::BaseMoving, _impl_.dimension_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseMoving, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseMoving, _impl_.orientation_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseMoving, _impl_.velocity_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseMoving, _impl_.acceleration_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseMoving, _impl_.orientation_rate_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseMoving, _impl_.orientation_acceleration_),
  PROTOBUF_FIELD_OFFSET(::osi3::BaseMoving, _impl_.base_polygon_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::StatePoint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::StatePoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::StatePoint, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::osi3::StatePoint, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::osi3::StatePoint, _impl_.orientation_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::WavelengthData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::WavelengthData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::WavelengthData, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::osi3::WavelengthData, _impl_.end_),
  PROTOBUF_FIELD_OFFSET(::osi3::WavelengthData, _impl_.samples_number_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::SpatialSignalStrength, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::SpatialSignalStrength, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::SpatialSignalStrength, _impl_.horizontal_angle_),
  PROTOBUF_FIELD_OFFSET(::osi3::SpatialSignalStrength, _impl_.vertical_angle_),
  PROTOBUF_FIELD_OFFSET(::osi3::SpatialSignalStrength, _impl_.signal_strength_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::ColorDescription, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorDescription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::ColorDescription, _impl_.grey_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorDescription, _impl_.rgb_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorDescription, _impl_.rgbir_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorDescription, _impl_.hsv_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorDescription, _impl_.luv_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorDescription, _impl_.cmyk_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::osi3::ColorGrey, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorGrey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::ColorGrey, _impl_.grey_),
  0,
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGB, _impl_.red_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGB, _impl_.green_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGB, _impl_.blue_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGBIR, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGBIR, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGBIR, _impl_.red_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGBIR, _impl_.green_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGBIR, _impl_.blue_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorRGBIR, _impl_.infrared_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::osi3::ColorHSV, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorHSV, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::ColorHSV, _impl_.hue_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorHSV, _impl_.saturation_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorHSV, _impl_.value_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::ColorLUV, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorLUV, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::ColorLUV, _impl_.luminance_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorLUV, _impl_.u_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorLUV, _impl_.v_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::ColorCMYK, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorCMYK, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::ColorCMYK, _impl_.cyan_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorCMYK, _impl_.magenta_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorCMYK, _impl_.yellow_),
  PROTOBUF_FIELD_OFFSET(::osi3::ColorCMYK, _impl_.key_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::osi3::Pedalry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::Pedalry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::Pedalry, _impl_.pedal_position_acceleration_),
  PROTOBUF_FIELD_OFFSET(::osi3::Pedalry, _impl_.pedal_position_brake_),
  PROTOBUF_FIELD_OFFSET(::osi3::Pedalry, _impl_.pedal_position_clutch_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::VehicleSteeringWheel, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::VehicleSteeringWheel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::VehicleSteeringWheel, _impl_.angle_),
  PROTOBUF_FIELD_OFFSET(::osi3::VehicleSteeringWheel, _impl_.angular_speed_),
  PROTOBUF_FIELD_OFFSET(::osi3::VehicleSteeringWheel, _impl_.torque_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::GeodeticPosition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::GeodeticPosition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::GeodeticPosition, _impl_.longitude_),
  PROTOBUF_FIELD_OFFSET(::osi3::GeodeticPosition, _impl_.latitude_),
  PROTOBUF_FIELD_OFFSET(::osi3::GeodeticPosition, _impl_.altitude_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::KeyValuePair, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::KeyValuePair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::KeyValuePair, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::osi3::KeyValuePair, _impl_.value_),
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::osi3::Vector3d)},
  { 12, 20, -1, sizeof(::osi3::Vector2d)},
  { 22, 30, -1, sizeof(::osi3::Timestamp)},
  { 32, 41, -1, sizeof(::osi3::Dimension3d)},
  { 44, 53, -1, sizeof(::osi3::Orientation3d)},
  { 56, 63, -1, sizeof(::osi3::Identifier)},
  { 64, 73, -1, sizeof(::osi3::ExternalReference)},
  { 76, 84, -1, sizeof(::osi3::MountingPosition)},
  { 86, 95, -1, sizeof(::osi3::Spherical3d)},
  { 98, 108, -1, sizeof(::osi3::LogicalLaneAssignment)},
  { 112, 122, -1, sizeof(::osi3::BaseStationary)},
  { 126, 140, -1, sizeof(::osi3::BaseMoving)},
  { 148, 157, -1, sizeof(::osi3::StatePoint)},
  { 160, 169, -1, sizeof(::osi3::WavelengthData)},
  { 172, 181, -1, sizeof(::osi3::SpatialSignalStrength)},
  { 184, 196, -1, sizeof(::osi3::ColorDescription)},
  { 202, 209, -1, sizeof(::osi3::ColorGrey)},
  { 210, 219, -1, sizeof(::osi3::ColorRGB)},
  { 222, 232, -1, sizeof(::osi3::ColorRGBIR)},
  { 236, 245, -1, sizeof(::osi3::ColorHSV)},
  { 248, 257, -1, sizeof(::osi3::ColorLUV)},
  { 260, 270, -1, sizeof(::osi3::ColorCMYK)},
  { 274, 283, -1, sizeof(::osi3::Pedalry)},
  { 286, 295, -1, sizeof(::osi3::VehicleSteeringWheel)},
  { 298, 307, -1, sizeof(::osi3::GeodeticPosition)},
  { 310, 318, -1, sizeof(::osi3::KeyValuePair)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::osi3::_Vector3d_default_instance_._instance,
  &::osi3::_Vector2d_default_instance_._instance,
  &::osi3::_Timestamp_default_instance_._instance,
  &::osi3::_Dimension3d_default_instance_._instance,
  &::osi3::_Orientation3d_default_instance_._instance,
  &::osi3::_Identifier_default_instance_._instance,
  &::osi3::_ExternalReference_default_instance_._instance,
  &::osi3::_MountingPosition_default_instance_._instance,
  &::osi3::_Spherical3d_default_instance_._instance,
  &::osi3::_LogicalLaneAssignment_default_instance_._instance,
  &::osi3::_BaseStationary_default_instance_._instance,
  &::osi3::_BaseMoving_default_instance_._instance,
  &::osi3::_StatePoint_default_instance_._instance,
  &::osi3::_WavelengthData_default_instance_._instance,
  &::osi3::_SpatialSignalStrength_default_instance_._instance,
  &::osi3::_ColorDescription_default_instance_._instance,
  &::osi3::_ColorGrey_default_instance_._instance,
  &::osi3::_ColorRGB_default_instance_._instance,
  &::osi3::_ColorRGBIR_default_instance_._instance,
  &::osi3::_ColorHSV_default_instance_._instance,
  &::osi3::_ColorLUV_default_instance_._instance,
  &::osi3::_ColorCMYK_default_instance_._instance,
  &::osi3::_Pedalry_default_instance_._instance,
  &::osi3::_VehicleSteeringWheel_default_instance_._instance,
  &::osi3::_GeodeticPosition_default_instance_._instance,
  &::osi3::_KeyValuePair_default_instance_._instance,
};

const char descriptor_table_protodef_osi_5fcommon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020osi_common.proto\022\004osi3\"+\n\010Vector3d\022\t\n\001"
  "x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\" \n\010Vector2"
  "d\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\"+\n\tTimestamp\022\017\n\007"
  "seconds\030\001 \001(\003\022\r\n\005nanos\030\002 \001(\r\"<\n\013Dimensio"
  "n3d\022\016\n\006length\030\001 \001(\001\022\r\n\005width\030\002 \001(\001\022\016\n\006he"
  "ight\030\003 \001(\001\"9\n\rOrientation3d\022\014\n\004roll\030\001 \001("
  "\001\022\r\n\005pitch\030\002 \001(\001\022\013\n\003yaw\030\003 \001(\001\"\033\n\nIdentif"
  "ier\022\r\n\005value\030\001 \001(\004\"H\n\021ExternalReference\022"
  "\021\n\treference\030\001 \001(\t\022\014\n\004type\030\002 \001(\t\022\022\n\niden"
  "tifier\030\003 \003(\t\"^\n\020MountingPosition\022 \n\010posi"
  "tion\030\001 \001(\0132\016.osi3.Vector3d\022(\n\013orientatio"
  "n\030\002 \001(\0132\023.osi3.Orientation3d\"C\n\013Spherica"
  "l3d\022\020\n\010distance\030\001 \001(\001\022\017\n\007azimuth\030\002 \001(\001\022\021"
  "\n\televation\030\003 \001(\001\"\202\001\n\025LogicalLaneAssignm"
  "ent\022*\n\020assigned_lane_id\030\001 \001(\0132\020.osi3.Ide"
  "ntifier\022\022\n\ns_position\030\002 \001(\001\022\022\n\nt_positio"
  "n\030\003 \001(\001\022\025\n\rangle_to_lane\030\004 \001(\001\"\250\001\n\016BaseS"
  "tationary\022$\n\tdimension\030\001 \001(\0132\021.osi3.Dime"
  "nsion3d\022 \n\010position\030\002 \001(\0132\016.osi3.Vector3"
  "d\022(\n\013orientation\030\003 \001(\0132\023.osi3.Orientatio"
  "n3d\022$\n\014base_polygon\030\004 \003(\0132\016.osi3.Vector2"
  "d\"\322\002\n\nBaseMoving\022$\n\tdimension\030\001 \001(\0132\021.os"
  "i3.Dimension3d\022 \n\010position\030\002 \001(\0132\016.osi3."
  "Vector3d\022(\n\013orientation\030\003 \001(\0132\023.osi3.Ori"
  "entation3d\022 \n\010velocity\030\004 \001(\0132\016.osi3.Vect"
  "or3d\022$\n\014acceleration\030\005 \001(\0132\016.osi3.Vector"
  "3d\022-\n\020orientation_rate\030\006 \001(\0132\023.osi3.Orie"
  "ntation3d\0225\n\030orientation_acceleration\030\010 "
  "\001(\0132\023.osi3.Orientation3d\022$\n\014base_polygon"
  "\030\007 \003(\0132\016.osi3.Vector2d\"|\n\nStatePoint\022\"\n\t"
  "timestamp\030\001 \001(\0132\017.osi3.Timestamp\022 \n\010posi"
  "tion\030\002 \001(\0132\016.osi3.Vector3d\022(\n\013orientatio"
  "n\030\003 \001(\0132\023.osi3.Orientation3d\"D\n\016Waveleng"
  "thData\022\r\n\005start\030\001 \001(\001\022\013\n\003end\030\002 \001(\001\022\026\n\016sa"
  "mples_number\030\003 \001(\001\"b\n\025SpatialSignalStren"
  "gth\022\030\n\020horizontal_angle\030\001 \001(\001\022\026\n\016vertica"
  "l_angle\030\002 \001(\001\022\027\n\017signal_strength\030\003 \001(\001\"\310"
  "\001\n\020ColorDescription\022\035\n\004grey\030\001 \001(\0132\017.osi3"
  ".ColorGrey\022\033\n\003rgb\030\002 \001(\0132\016.osi3.ColorRGB\022"
  "\037\n\005rgbir\030\003 \001(\0132\020.osi3.ColorRGBIR\022\033\n\003hsv\030"
  "\004 \001(\0132\016.osi3.ColorHSV\022\033\n\003luv\030\005 \001(\0132\016.osi"
  "3.ColorLUV\022\035\n\004cmyk\030\006 \001(\0132\017.osi3.ColorCMY"
  "K\"\031\n\tColorGrey\022\014\n\004grey\030\001 \001(\001\"4\n\010ColorRGB"
  "\022\013\n\003red\030\001 \001(\001\022\r\n\005green\030\002 \001(\001\022\014\n\004blue\030\003 \001"
  "(\001\"H\n\nColorRGBIR\022\013\n\003red\030\001 \001(\001\022\r\n\005green\030\002"
  " \001(\001\022\014\n\004blue\030\003 \001(\001\022\020\n\010infrared\030\004 \001(\001\":\n\010"
  "ColorHSV\022\013\n\003hue\030\001 \001(\001\022\022\n\nsaturation\030\002 \001("
  "\001\022\r\n\005value\030\003 \001(\001\"3\n\010ColorLUV\022\021\n\tluminanc"
  "e\030\001 \001(\001\022\t\n\001u\030\002 \001(\001\022\t\n\001v\030\003 \001(\001\"G\n\tColorCM"
  "YK\022\014\n\004cyan\030\001 \001(\001\022\017\n\007magenta\030\002 \001(\001\022\016\n\006yel"
  "low\030\003 \001(\001\022\013\n\003key\030\004 \001(\001\"k\n\007Pedalry\022#\n\033ped"
  "al_position_acceleration\030\001 \001(\001\022\034\n\024pedal_"
  "position_brake\030\002 \001(\001\022\035\n\025pedal_position_c"
  "lutch\030\003 \001(\001\"L\n\024VehicleSteeringWheel\022\r\n\005a"
  "ngle\030\001 \001(\001\022\025\n\rangular_speed\030\002 \001(\001\022\016\n\006tor"
  "que\030\003 \001(\001\"I\n\020GeodeticPosition\022\021\n\tlongitu"
  "de\030\001 \001(\001\022\020\n\010latitude\030\002 \001(\001\022\020\n\010altitude\030\003"
  " \001(\001\"*\n\014KeyValuePair\022\013\n\003key\030\001 \001(\t\022\r\n\005val"
  "ue\030\002 \001(\tB\002H\001"
  ;
static ::_pbi::once_flag descriptor_table_osi_5fcommon_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_osi_5fcommon_2eproto = {
    false, false, 2332, descriptor_table_protodef_osi_5fcommon_2eproto,
    "osi_common.proto",
    &descriptor_table_osi_5fcommon_2eproto_once, nullptr, 0, 26,
    schemas, file_default_instances, TableStruct_osi_5fcommon_2eproto::offsets,
    file_level_metadata_osi_5fcommon_2eproto, file_level_enum_descriptors_osi_5fcommon_2eproto,
    file_level_service_descriptors_osi_5fcommon_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_osi_5fcommon_2eproto_getter() {
  return &descriptor_table_osi_5fcommon_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_osi_5fcommon_2eproto(&descriptor_table_osi_5fcommon_2eproto);
namespace osi3 {

// ===================================================================

class Vector3d::_Internal {
 public:
  using HasBits = decltype(std::declval<Vector3d>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Vector3d::Vector3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.Vector3d)
}
Vector3d::Vector3d(const Vector3d& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vector3d* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:osi3.Vector3d)
}

inline void Vector3d::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
  };
}

Vector3d::~Vector3d() {
  // @@protoc_insertion_point(destructor:osi3.Vector3d)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vector3d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector3d::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vector3d::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Vector3d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector3d::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vector3d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Vector3d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Vector3d)
  return target;
}

size_t Vector3d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Vector3d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector3d::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vector3d::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector3d::GetClassData() const { return &_class_data_; }


void Vector3d::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vector3d*>(&to_msg);
  auto& from = static_cast<const Vector3d&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Vector3d)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector3d::CopyFrom(const Vector3d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Vector3d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector3d::IsInitialized() const {
  return true;
}

void Vector3d::InternalSwap(Vector3d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector3d, _impl_.z_)
      + sizeof(Vector3d::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Vector3d, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector3d::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[0]);
}

// ===================================================================

class Vector2d::_Internal {
 public:
  using HasBits = decltype(std::declval<Vector2d>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Vector2d::Vector2d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.Vector2d)
}
Vector2d::Vector2d(const Vector2d& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vector2d* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:osi3.Vector2d)
}

inline void Vector2d::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

Vector2d::~Vector2d() {
  // @@protoc_insertion_point(destructor:osi3.Vector2d)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vector2d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector2d::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vector2d::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Vector2d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector2d::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vector2d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Vector2d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Vector2d)
  return target;
}

size_t Vector2d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Vector2d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector2d::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vector2d::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector2d::GetClassData() const { return &_class_data_; }


void Vector2d::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vector2d*>(&to_msg);
  auto& from = static_cast<const Vector2d&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Vector2d)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector2d::CopyFrom(const Vector2d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Vector2d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector2d::IsInitialized() const {
  return true;
}

void Vector2d::InternalSwap(Vector2d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector2d, _impl_.y_)
      + sizeof(Vector2d::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Vector2d, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector2d::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[1]);
}

// ===================================================================

class Timestamp::_Internal {
 public:
  using HasBits = decltype(std::declval<Timestamp>()._impl_._has_bits_);
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nanos(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Timestamp::Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.Timestamp)
}
Timestamp::Timestamp(const Timestamp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Timestamp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seconds_){}
    , decltype(_impl_.nanos_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.seconds_, &from._impl_.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanos_) -
    reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
  // @@protoc_insertion_point(copy_constructor:osi3.Timestamp)
}

inline void Timestamp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seconds_){int64_t{0}}
    , decltype(_impl_.nanos_){0u}
  };
}

Timestamp::~Timestamp() {
  // @@protoc_insertion_point(destructor:osi3.Timestamp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Timestamp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Timestamp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Timestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Timestamp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.nanos_) -
        reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Timestamp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seconds(&has_bits);
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nanos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nanos(&has_bits);
          _impl_.nanos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Timestamp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Timestamp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
  }

  // optional uint32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nanos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Timestamp)
  return target;
}

size_t Timestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Timestamp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 seconds = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seconds());
    }

    // optional uint32 nanos = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nanos());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Timestamp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Timestamp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Timestamp::GetClassData() const { return &_class_data_; }


void Timestamp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Timestamp*>(&to_msg);
  auto& from = static_cast<const Timestamp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Timestamp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.seconds_ = from._impl_.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nanos_ = from._impl_.nanos_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Timestamp::CopyFrom(const Timestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Timestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timestamp::IsInitialized() const {
  return true;
}

void Timestamp::InternalSwap(Timestamp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.nanos_)
      + sizeof(Timestamp::_impl_.nanos_)
      - PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Timestamp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[2]);
}

// ===================================================================

class Dimension3d::_Internal {
 public:
  using HasBits = decltype(std::declval<Dimension3d>()._impl_._has_bits_);
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Dimension3d::Dimension3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.Dimension3d)
}
Dimension3d::Dimension3d(const Dimension3d& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Dimension3d* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.length_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.length_, &from._impl_.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:osi3.Dimension3d)
}

inline void Dimension3d::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.length_){0}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
  };
}

Dimension3d::~Dimension3d() {
  // @@protoc_insertion_point(destructor:osi3.Dimension3d)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Dimension3d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Dimension3d::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Dimension3d::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Dimension3d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.height_) -
        reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.height_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Dimension3d::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Dimension3d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Dimension3d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double length = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_length(), target);
  }

  // optional double width = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_width(), target);
  }

  // optional double height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Dimension3d)
  return target;
}

size_t Dimension3d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Dimension3d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double length = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double width = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double height = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Dimension3d::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Dimension3d::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Dimension3d::GetClassData() const { return &_class_data_; }


void Dimension3d::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Dimension3d*>(&to_msg);
  auto& from = static_cast<const Dimension3d&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Dimension3d)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Dimension3d::CopyFrom(const Dimension3d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Dimension3d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dimension3d::IsInitialized() const {
  return true;
}

void Dimension3d::InternalSwap(Dimension3d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Dimension3d, _impl_.height_)
      + sizeof(Dimension3d::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(Dimension3d, _impl_.length_)>(
          reinterpret_cast<char*>(&_impl_.length_),
          reinterpret_cast<char*>(&other->_impl_.length_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Dimension3d::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[3]);
}

// ===================================================================

class Orientation3d::_Internal {
 public:
  using HasBits = decltype(std::declval<Orientation3d>()._impl_._has_bits_);
  static void set_has_roll(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Orientation3d::Orientation3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.Orientation3d)
}
Orientation3d::Orientation3d(const Orientation3d& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Orientation3d* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roll_){}
    , decltype(_impl_.pitch_){}
    , decltype(_impl_.yaw_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.roll_, &from._impl_.roll_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.yaw_) -
    reinterpret_cast<char*>(&_impl_.roll_)) + sizeof(_impl_.yaw_));
  // @@protoc_insertion_point(copy_constructor:osi3.Orientation3d)
}

inline void Orientation3d::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roll_){0}
    , decltype(_impl_.pitch_){0}
    , decltype(_impl_.yaw_){0}
  };
}

Orientation3d::~Orientation3d() {
  // @@protoc_insertion_point(destructor:osi3.Orientation3d)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Orientation3d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Orientation3d::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Orientation3d::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Orientation3d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.roll_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.yaw_) -
        reinterpret_cast<char*>(&_impl_.roll_)) + sizeof(_impl_.yaw_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Orientation3d::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double roll = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_roll(&has_bits);
          _impl_.roll_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double pitch = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_pitch(&has_bits);
          _impl_.pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double yaw = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_yaw(&has_bits);
          _impl_.yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Orientation3d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Orientation3d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double roll = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_roll(), target);
  }

  // optional double pitch = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_pitch(), target);
  }

  // optional double yaw = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_yaw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Orientation3d)
  return target;
}

size_t Orientation3d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Orientation3d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double roll = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double pitch = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double yaw = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Orientation3d::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Orientation3d::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Orientation3d::GetClassData() const { return &_class_data_; }


void Orientation3d::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Orientation3d*>(&to_msg);
  auto& from = static_cast<const Orientation3d&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Orientation3d)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.roll_ = from._impl_.roll_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pitch_ = from._impl_.pitch_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.yaw_ = from._impl_.yaw_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Orientation3d::CopyFrom(const Orientation3d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Orientation3d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Orientation3d::IsInitialized() const {
  return true;
}

void Orientation3d::InternalSwap(Orientation3d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Orientation3d, _impl_.yaw_)
      + sizeof(Orientation3d::_impl_.yaw_)
      - PROTOBUF_FIELD_OFFSET(Orientation3d, _impl_.roll_)>(
          reinterpret_cast<char*>(&_impl_.roll_),
          reinterpret_cast<char*>(&other->_impl_.roll_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Orientation3d::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[4]);
}

// ===================================================================

class Identifier::_Internal {
 public:
  using HasBits = decltype(std::declval<Identifier>()._impl_._has_bits_);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Identifier::Identifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.Identifier)
}
Identifier::Identifier(const Identifier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Identifier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.value_ = from._impl_.value_;
  // @@protoc_insertion_point(copy_constructor:osi3.Identifier)
}

inline void Identifier::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){uint64_t{0u}}
  };
}

Identifier::~Identifier() {
  // @@protoc_insertion_point(destructor:osi3.Identifier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Identifier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Identifier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Identifier::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Identifier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Identifier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Identifier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Identifier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Identifier)
  return target;
}

size_t Identifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Identifier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 value = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Identifier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Identifier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Identifier::GetClassData() const { return &_class_data_; }


void Identifier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Identifier*>(&to_msg);
  auto& from = static_cast<const Identifier&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Identifier)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Identifier::CopyFrom(const Identifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Identifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Identifier::IsInitialized() const {
  return true;
}

void Identifier::InternalSwap(Identifier* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Identifier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[5]);
}

// ===================================================================

class ExternalReference::_Internal {
 public:
  using HasBits = decltype(std::declval<ExternalReference>()._impl_._has_bits_);
  static void set_has_reference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ExternalReference::ExternalReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.ExternalReference)
}
ExternalReference::ExternalReference(const ExternalReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExternalReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){from._impl_.identifier_}
    , decltype(_impl_.reference_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.reference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reference()) {
    _this->_impl_.reference_.Set(from._internal_reference(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:osi3.ExternalReference)
}

inline void ExternalReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){arena}
    , decltype(_impl_.reference_){}
    , decltype(_impl_.type_){}
  };
  _impl_.reference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExternalReference::~ExternalReference() {
  // @@protoc_insertion_point(destructor:osi3.ExternalReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExternalReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.identifier_.~RepeatedPtrField();
  _impl_.reference_.Destroy();
  _impl_.type_.Destroy();
}

void ExternalReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExternalReference::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.ExternalReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.identifier_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.reference_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExternalReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string reference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_reference();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "osi3.ExternalReference.reference");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "osi3.ExternalReference.type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_identifier();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "osi3.ExternalReference.identifier");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExternalReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.ExternalReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string reference = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_reference().data(), static_cast<int>(this->_internal_reference().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "osi3.ExternalReference.reference");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_reference(), target);
  }

  // optional string type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "osi3.ExternalReference.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  // repeated string identifier = 3;
  for (int i = 0, n = this->_internal_identifier_size(); i < n; i++) {
    const auto& s = this->_internal_identifier(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "osi3.ExternalReference.identifier");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.ExternalReference)
  return target;
}

size_t ExternalReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.ExternalReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string identifier = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.identifier_.size());
  for (int i = 0, n = _impl_.identifier_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.identifier_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string reference = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reference());
    }

    // optional string type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExternalReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExternalReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExternalReference::GetClassData() const { return &_class_data_; }


void ExternalReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExternalReference*>(&to_msg);
  auto& from = static_cast<const ExternalReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.ExternalReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.identifier_.MergeFrom(from._impl_.identifier_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_reference(from._internal_reference());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_type(from._internal_type());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExternalReference::CopyFrom(const ExternalReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.ExternalReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExternalReference::IsInitialized() const {
  return true;
}

void ExternalReference::InternalSwap(ExternalReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.identifier_.InternalSwap(&other->_impl_.identifier_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reference_, lhs_arena,
      &other->_impl_.reference_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ExternalReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[6]);
}

// ===================================================================

class MountingPosition::_Internal {
 public:
  using HasBits = decltype(std::declval<MountingPosition>()._impl_._has_bits_);
  static const ::osi3::Vector3d& position(const MountingPosition* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Orientation3d& orientation(const MountingPosition* msg);
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::osi3::Vector3d&
MountingPosition::_Internal::position(const MountingPosition* msg) {
  return *msg->_impl_.position_;
}
const ::osi3::Orientation3d&
MountingPosition::_Internal::orientation(const MountingPosition* msg) {
  return *msg->_impl_.orientation_;
}
MountingPosition::MountingPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.MountingPosition)
}
MountingPosition::MountingPosition(const MountingPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MountingPosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.orientation_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::osi3::Vector3d(*from._impl_.position_);
  }
  if (from._internal_has_orientation()) {
    _this->_impl_.orientation_ = new ::osi3::Orientation3d(*from._impl_.orientation_);
  }
  // @@protoc_insertion_point(copy_constructor:osi3.MountingPosition)
}

inline void MountingPosition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.orientation_){nullptr}
  };
}

MountingPosition::~MountingPosition() {
  // @@protoc_insertion_point(destructor:osi3.MountingPosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MountingPosition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.orientation_;
}

void MountingPosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MountingPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.MountingPosition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.orientation_ != nullptr);
      _impl_.orientation_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MountingPosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.Vector3d position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Orientation3d orientation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MountingPosition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.MountingPosition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.Vector3d position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Orientation3d orientation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::orientation(this),
        _Internal::orientation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.MountingPosition)
  return target;
}

size_t MountingPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.MountingPosition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .osi3.Vector3d position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .osi3.Orientation3d orientation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.orientation_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MountingPosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MountingPosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MountingPosition::GetClassData() const { return &_class_data_; }


void MountingPosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MountingPosition*>(&to_msg);
  auto& from = static_cast<const MountingPosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.MountingPosition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::osi3::Vector3d::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_orientation()->::osi3::Orientation3d::MergeFrom(
          from._internal_orientation());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MountingPosition::CopyFrom(const MountingPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.MountingPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MountingPosition::IsInitialized() const {
  return true;
}

void MountingPosition::InternalSwap(MountingPosition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MountingPosition, _impl_.orientation_)
      + sizeof(MountingPosition::_impl_.orientation_)
      - PROTOBUF_FIELD_OFFSET(MountingPosition, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MountingPosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[7]);
}

// ===================================================================

class Spherical3d::_Internal {
 public:
  using HasBits = decltype(std::declval<Spherical3d>()._impl_._has_bits_);
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_azimuth(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_elevation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Spherical3d::Spherical3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.Spherical3d)
}
Spherical3d::Spherical3d(const Spherical3d& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Spherical3d* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.distance_){}
    , decltype(_impl_.azimuth_){}
    , decltype(_impl_.elevation_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.distance_, &from._impl_.distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.elevation_) -
    reinterpret_cast<char*>(&_impl_.distance_)) + sizeof(_impl_.elevation_));
  // @@protoc_insertion_point(copy_constructor:osi3.Spherical3d)
}

inline void Spherical3d::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.distance_){0}
    , decltype(_impl_.azimuth_){0}
    , decltype(_impl_.elevation_){0}
  };
}

Spherical3d::~Spherical3d() {
  // @@protoc_insertion_point(destructor:osi3.Spherical3d)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Spherical3d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Spherical3d::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Spherical3d::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Spherical3d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.distance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.elevation_) -
        reinterpret_cast<char*>(&_impl_.distance_)) + sizeof(_impl_.elevation_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Spherical3d::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double distance = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_distance(&has_bits);
          _impl_.distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double azimuth = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_azimuth(&has_bits);
          _impl_.azimuth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double elevation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_elevation(&has_bits);
          _impl_.elevation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Spherical3d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Spherical3d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double distance = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_distance(), target);
  }

  // optional double azimuth = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_azimuth(), target);
  }

  // optional double elevation = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_elevation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Spherical3d)
  return target;
}

size_t Spherical3d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Spherical3d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double distance = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double azimuth = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double elevation = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Spherical3d::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Spherical3d::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Spherical3d::GetClassData() const { return &_class_data_; }


void Spherical3d::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Spherical3d*>(&to_msg);
  auto& from = static_cast<const Spherical3d&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Spherical3d)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.distance_ = from._impl_.distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.azimuth_ = from._impl_.azimuth_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.elevation_ = from._impl_.elevation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Spherical3d::CopyFrom(const Spherical3d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Spherical3d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Spherical3d::IsInitialized() const {
  return true;
}

void Spherical3d::InternalSwap(Spherical3d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Spherical3d, _impl_.elevation_)
      + sizeof(Spherical3d::_impl_.elevation_)
      - PROTOBUF_FIELD_OFFSET(Spherical3d, _impl_.distance_)>(
          reinterpret_cast<char*>(&_impl_.distance_),
          reinterpret_cast<char*>(&other->_impl_.distance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Spherical3d::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[8]);
}

// ===================================================================

class LogicalLaneAssignment::_Internal {
 public:
  using HasBits = decltype(std::declval<LogicalLaneAssignment>()._impl_._has_bits_);
  static const ::osi3::Identifier& assigned_lane_id(const LogicalLaneAssignment* msg);
  static void set_has_assigned_lane_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_s_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_t_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_angle_to_lane(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::osi3::Identifier&
LogicalLaneAssignment::_Internal::assigned_lane_id(const LogicalLaneAssignment* msg) {
  return *msg->_impl_.assigned_lane_id_;
}
LogicalLaneAssignment::LogicalLaneAssignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.LogicalLaneAssignment)
}
LogicalLaneAssignment::LogicalLaneAssignment(const LogicalLaneAssignment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LogicalLaneAssignment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.assigned_lane_id_){nullptr}
    , decltype(_impl_.s_position_){}
    , decltype(_impl_.t_position_){}
    , decltype(_impl_.angle_to_lane_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_assigned_lane_id()) {
    _this->_impl_.assigned_lane_id_ = new ::osi3::Identifier(*from._impl_.assigned_lane_id_);
  }
  ::memcpy(&_impl_.s_position_, &from._impl_.s_position_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.angle_to_lane_) -
    reinterpret_cast<char*>(&_impl_.s_position_)) + sizeof(_impl_.angle_to_lane_));
  // @@protoc_insertion_point(copy_constructor:osi3.LogicalLaneAssignment)
}

inline void LogicalLaneAssignment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.assigned_lane_id_){nullptr}
    , decltype(_impl_.s_position_){0}
    , decltype(_impl_.t_position_){0}
    , decltype(_impl_.angle_to_lane_){0}
  };
}

LogicalLaneAssignment::~LogicalLaneAssignment() {
  // @@protoc_insertion_point(destructor:osi3.LogicalLaneAssignment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogicalLaneAssignment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.assigned_lane_id_;
}

void LogicalLaneAssignment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogicalLaneAssignment::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LogicalLaneAssignment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.assigned_lane_id_ != nullptr);
    _impl_.assigned_lane_id_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.s_position_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.angle_to_lane_) -
        reinterpret_cast<char*>(&_impl_.s_position_)) + sizeof(_impl_.angle_to_lane_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogicalLaneAssignment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.Identifier assigned_lane_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_assigned_lane_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double s_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_s_position(&has_bits);
          _impl_.s_position_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double t_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_t_position(&has_bits);
          _impl_.t_position_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double angle_to_lane = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_angle_to_lane(&has_bits);
          _impl_.angle_to_lane_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogicalLaneAssignment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.LogicalLaneAssignment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.Identifier assigned_lane_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::assigned_lane_id(this),
        _Internal::assigned_lane_id(this).GetCachedSize(), target, stream);
  }

  // optional double s_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_s_position(), target);
  }

  // optional double t_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_t_position(), target);
  }

  // optional double angle_to_lane = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_angle_to_lane(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.LogicalLaneAssignment)
  return target;
}

size_t LogicalLaneAssignment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.LogicalLaneAssignment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .osi3.Identifier assigned_lane_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.assigned_lane_id_);
    }

    // optional double s_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double t_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double angle_to_lane = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogicalLaneAssignment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogicalLaneAssignment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogicalLaneAssignment::GetClassData() const { return &_class_data_; }


void LogicalLaneAssignment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LogicalLaneAssignment*>(&to_msg);
  auto& from = static_cast<const LogicalLaneAssignment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LogicalLaneAssignment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_assigned_lane_id()->::osi3::Identifier::MergeFrom(
          from._internal_assigned_lane_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.s_position_ = from._impl_.s_position_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.t_position_ = from._impl_.t_position_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.angle_to_lane_ = from._impl_.angle_to_lane_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogicalLaneAssignment::CopyFrom(const LogicalLaneAssignment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LogicalLaneAssignment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalLaneAssignment::IsInitialized() const {
  return true;
}

void LogicalLaneAssignment::InternalSwap(LogicalLaneAssignment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogicalLaneAssignment, _impl_.angle_to_lane_)
      + sizeof(LogicalLaneAssignment::_impl_.angle_to_lane_)
      - PROTOBUF_FIELD_OFFSET(LogicalLaneAssignment, _impl_.assigned_lane_id_)>(
          reinterpret_cast<char*>(&_impl_.assigned_lane_id_),
          reinterpret_cast<char*>(&other->_impl_.assigned_lane_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogicalLaneAssignment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[9]);
}

// ===================================================================

class BaseStationary::_Internal {
 public:
  using HasBits = decltype(std::declval<BaseStationary>()._impl_._has_bits_);
  static const ::osi3::Dimension3d& dimension(const BaseStationary* msg);
  static void set_has_dimension(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Vector3d& position(const BaseStationary* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Orientation3d& orientation(const BaseStationary* msg);
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::osi3::Dimension3d&
BaseStationary::_Internal::dimension(const BaseStationary* msg) {
  return *msg->_impl_.dimension_;
}
const ::osi3::Vector3d&
BaseStationary::_Internal::position(const BaseStationary* msg) {
  return *msg->_impl_.position_;
}
const ::osi3::Orientation3d&
BaseStationary::_Internal::orientation(const BaseStationary* msg) {
  return *msg->_impl_.orientation_;
}
BaseStationary::BaseStationary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.BaseStationary)
}
BaseStationary::BaseStationary(const BaseStationary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BaseStationary* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_polygon_){from._impl_.base_polygon_}
    , decltype(_impl_.dimension_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.orientation_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dimension()) {
    _this->_impl_.dimension_ = new ::osi3::Dimension3d(*from._impl_.dimension_);
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::osi3::Vector3d(*from._impl_.position_);
  }
  if (from._internal_has_orientation()) {
    _this->_impl_.orientation_ = new ::osi3::Orientation3d(*from._impl_.orientation_);
  }
  // @@protoc_insertion_point(copy_constructor:osi3.BaseStationary)
}

inline void BaseStationary::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_polygon_){arena}
    , decltype(_impl_.dimension_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.orientation_){nullptr}
  };
}

BaseStationary::~BaseStationary() {
  // @@protoc_insertion_point(destructor:osi3.BaseStationary)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BaseStationary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.base_polygon_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.dimension_;
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.orientation_;
}

void BaseStationary::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BaseStationary::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.BaseStationary)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.base_polygon_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.dimension_ != nullptr);
      _impl_.dimension_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.orientation_ != nullptr);
      _impl_.orientation_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BaseStationary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.Dimension3d dimension = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dimension(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Vector3d position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Orientation3d orientation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.Vector2d base_polygon = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_base_polygon(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BaseStationary::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.BaseStationary)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.Dimension3d dimension = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::dimension(this),
        _Internal::dimension(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Vector3d position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Orientation3d orientation = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::orientation(this),
        _Internal::orientation(this).GetCachedSize(), target, stream);
  }

  // repeated .osi3.Vector2d base_polygon = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_base_polygon_size()); i < n; i++) {
    const auto& repfield = this->_internal_base_polygon(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.BaseStationary)
  return target;
}

size_t BaseStationary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.BaseStationary)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.Vector2d base_polygon = 4;
  total_size += 1UL * this->_internal_base_polygon_size();
  for (const auto& msg : this->_impl_.base_polygon_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .osi3.Dimension3d dimension = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dimension_);
    }

    // optional .osi3.Vector3d position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .osi3.Orientation3d orientation = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.orientation_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BaseStationary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BaseStationary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BaseStationary::GetClassData() const { return &_class_data_; }


void BaseStationary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BaseStationary*>(&to_msg);
  auto& from = static_cast<const BaseStationary&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.BaseStationary)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.base_polygon_.MergeFrom(from._impl_.base_polygon_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_dimension()->::osi3::Dimension3d::MergeFrom(
          from._internal_dimension());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_position()->::osi3::Vector3d::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_orientation()->::osi3::Orientation3d::MergeFrom(
          from._internal_orientation());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BaseStationary::CopyFrom(const BaseStationary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.BaseStationary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseStationary::IsInitialized() const {
  return true;
}

void BaseStationary::InternalSwap(BaseStationary* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.base_polygon_.InternalSwap(&other->_impl_.base_polygon_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BaseStationary, _impl_.orientation_)
      + sizeof(BaseStationary::_impl_.orientation_)
      - PROTOBUF_FIELD_OFFSET(BaseStationary, _impl_.dimension_)>(
          reinterpret_cast<char*>(&_impl_.dimension_),
          reinterpret_cast<char*>(&other->_impl_.dimension_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BaseStationary::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[10]);
}

// ===================================================================

class BaseMoving::_Internal {
 public:
  using HasBits = decltype(std::declval<BaseMoving>()._impl_._has_bits_);
  static const ::osi3::Dimension3d& dimension(const BaseMoving* msg);
  static void set_has_dimension(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Vector3d& position(const BaseMoving* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Orientation3d& orientation(const BaseMoving* msg);
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::osi3::Vector3d& velocity(const BaseMoving* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::osi3::Vector3d& acceleration(const BaseMoving* msg);
  static void set_has_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::osi3::Orientation3d& orientation_rate(const BaseMoving* msg);
  static void set_has_orientation_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::osi3::Orientation3d& orientation_acceleration(const BaseMoving* msg);
  static void set_has_orientation_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::osi3::Dimension3d&
BaseMoving::_Internal::dimension(const BaseMoving* msg) {
  return *msg->_impl_.dimension_;
}
const ::osi3::Vector3d&
BaseMoving::_Internal::position(const BaseMoving* msg) {
  return *msg->_impl_.position_;
}
const ::osi3::Orientation3d&
BaseMoving::_Internal::orientation(const BaseMoving* msg) {
  return *msg->_impl_.orientation_;
}
const ::osi3::Vector3d&
BaseMoving::_Internal::velocity(const BaseMoving* msg) {
  return *msg->_impl_.velocity_;
}
const ::osi3::Vector3d&
BaseMoving::_Internal::acceleration(const BaseMoving* msg) {
  return *msg->_impl_.acceleration_;
}
const ::osi3::Orientation3d&
BaseMoving::_Internal::orientation_rate(const BaseMoving* msg) {
  return *msg->_impl_.orientation_rate_;
}
const ::osi3::Orientation3d&
BaseMoving::_Internal::orientation_acceleration(const BaseMoving* msg) {
  return *msg->_impl_.orientation_acceleration_;
}
BaseMoving::BaseMoving(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.BaseMoving)
}
BaseMoving::BaseMoving(const BaseMoving& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BaseMoving* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_polygon_){from._impl_.base_polygon_}
    , decltype(_impl_.dimension_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.orientation_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.acceleration_){nullptr}
    , decltype(_impl_.orientation_rate_){nullptr}
    , decltype(_impl_.orientation_acceleration_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dimension()) {
    _this->_impl_.dimension_ = new ::osi3::Dimension3d(*from._impl_.dimension_);
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::osi3::Vector3d(*from._impl_.position_);
  }
  if (from._internal_has_orientation()) {
    _this->_impl_.orientation_ = new ::osi3::Orientation3d(*from._impl_.orientation_);
  }
  if (from._internal_has_velocity()) {
    _this->_impl_.velocity_ = new ::osi3::Vector3d(*from._impl_.velocity_);
  }
  if (from._internal_has_acceleration()) {
    _this->_impl_.acceleration_ = new ::osi3::Vector3d(*from._impl_.acceleration_);
  }
  if (from._internal_has_orientation_rate()) {
    _this->_impl_.orientation_rate_ = new ::osi3::Orientation3d(*from._impl_.orientation_rate_);
  }
  if (from._internal_has_orientation_acceleration()) {
    _this->_impl_.orientation_acceleration_ = new ::osi3::Orientation3d(*from._impl_.orientation_acceleration_);
  }
  // @@protoc_insertion_point(copy_constructor:osi3.BaseMoving)
}

inline void BaseMoving::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_polygon_){arena}
    , decltype(_impl_.dimension_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.orientation_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.acceleration_){nullptr}
    , decltype(_impl_.orientation_rate_){nullptr}
    , decltype(_impl_.orientation_acceleration_){nullptr}
  };
}

BaseMoving::~BaseMoving() {
  // @@protoc_insertion_point(destructor:osi3.BaseMoving)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BaseMoving::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.base_polygon_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.dimension_;
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.orientation_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.acceleration_;
  if (this != internal_default_instance()) delete _impl_.orientation_rate_;
  if (this != internal_default_instance()) delete _impl_.orientation_acceleration_;
}

void BaseMoving::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BaseMoving::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.BaseMoving)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.base_polygon_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.dimension_ != nullptr);
      _impl_.dimension_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.orientation_ != nullptr);
      _impl_.orientation_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.acceleration_ != nullptr);
      _impl_.acceleration_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.orientation_rate_ != nullptr);
      _impl_.orientation_rate_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.orientation_acceleration_ != nullptr);
      _impl_.orientation_acceleration_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BaseMoving::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.Dimension3d dimension = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dimension(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Vector3d position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Orientation3d orientation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Vector3d velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Vector3d acceleration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_acceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Orientation3d orientation_rate = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation_rate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.Vector2d base_polygon = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_base_polygon(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Orientation3d orientation_acceleration = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation_acceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BaseMoving::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.BaseMoving)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.Dimension3d dimension = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::dimension(this),
        _Internal::dimension(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Vector3d position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Orientation3d orientation = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::orientation(this),
        _Internal::orientation(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Vector3d velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Vector3d acceleration = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::acceleration(this),
        _Internal::acceleration(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Orientation3d orientation_rate = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::orientation_rate(this),
        _Internal::orientation_rate(this).GetCachedSize(), target, stream);
  }

  // repeated .osi3.Vector2d base_polygon = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_base_polygon_size()); i < n; i++) {
    const auto& repfield = this->_internal_base_polygon(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .osi3.Orientation3d orientation_acceleration = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::orientation_acceleration(this),
        _Internal::orientation_acceleration(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.BaseMoving)
  return target;
}

size_t BaseMoving::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.BaseMoving)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.Vector2d base_polygon = 7;
  total_size += 1UL * this->_internal_base_polygon_size();
  for (const auto& msg : this->_impl_.base_polygon_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .osi3.Dimension3d dimension = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dimension_);
    }

    // optional .osi3.Vector3d position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .osi3.Orientation3d orientation = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.orientation_);
    }

    // optional .osi3.Vector3d velocity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // optional .osi3.Vector3d acceleration = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.acceleration_);
    }

    // optional .osi3.Orientation3d orientation_rate = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.orientation_rate_);
    }

    // optional .osi3.Orientation3d orientation_acceleration = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.orientation_acceleration_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BaseMoving::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BaseMoving::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BaseMoving::GetClassData() const { return &_class_data_; }


void BaseMoving::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BaseMoving*>(&to_msg);
  auto& from = static_cast<const BaseMoving&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.BaseMoving)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.base_polygon_.MergeFrom(from._impl_.base_polygon_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_dimension()->::osi3::Dimension3d::MergeFrom(
          from._internal_dimension());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_position()->::osi3::Vector3d::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_orientation()->::osi3::Orientation3d::MergeFrom(
          from._internal_orientation());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_velocity()->::osi3::Vector3d::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_acceleration()->::osi3::Vector3d::MergeFrom(
          from._internal_acceleration());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_orientation_rate()->::osi3::Orientation3d::MergeFrom(
          from._internal_orientation_rate());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_orientation_acceleration()->::osi3::Orientation3d::MergeFrom(
          from._internal_orientation_acceleration());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BaseMoving::CopyFrom(const BaseMoving& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.BaseMoving)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseMoving::IsInitialized() const {
  return true;
}

void BaseMoving::InternalSwap(BaseMoving* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.base_polygon_.InternalSwap(&other->_impl_.base_polygon_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BaseMoving, _impl_.orientation_acceleration_)
      + sizeof(BaseMoving::_impl_.orientation_acceleration_)
      - PROTOBUF_FIELD_OFFSET(BaseMoving, _impl_.dimension_)>(
          reinterpret_cast<char*>(&_impl_.dimension_),
          reinterpret_cast<char*>(&other->_impl_.dimension_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BaseMoving::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[11]);
}

// ===================================================================

class StatePoint::_Internal {
 public:
  using HasBits = decltype(std::declval<StatePoint>()._impl_._has_bits_);
  static const ::osi3::Timestamp& timestamp(const StatePoint* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Vector3d& position(const StatePoint* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Orientation3d& orientation(const StatePoint* msg);
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::osi3::Timestamp&
StatePoint::_Internal::timestamp(const StatePoint* msg) {
  return *msg->_impl_.timestamp_;
}
const ::osi3::Vector3d&
StatePoint::_Internal::position(const StatePoint* msg) {
  return *msg->_impl_.position_;
}
const ::osi3::Orientation3d&
StatePoint::_Internal::orientation(const StatePoint* msg) {
  return *msg->_impl_.orientation_;
}
StatePoint::StatePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.StatePoint)
}
StatePoint::StatePoint(const StatePoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatePoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.orientation_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::osi3::Timestamp(*from._impl_.timestamp_);
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::osi3::Vector3d(*from._impl_.position_);
  }
  if (from._internal_has_orientation()) {
    _this->_impl_.orientation_ = new ::osi3::Orientation3d(*from._impl_.orientation_);
  }
  // @@protoc_insertion_point(copy_constructor:osi3.StatePoint)
}

inline void StatePoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.orientation_){nullptr}
  };
}

StatePoint::~StatePoint() {
  // @@protoc_insertion_point(destructor:osi3.StatePoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatePoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.timestamp_;
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.orientation_;
}

void StatePoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatePoint::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.StatePoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.timestamp_ != nullptr);
      _impl_.timestamp_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.orientation_ != nullptr);
      _impl_.orientation_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatePoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.Timestamp timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Vector3d position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Orientation3d orientation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatePoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.StatePoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.Timestamp timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Vector3d position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Orientation3d orientation = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::orientation(this),
        _Internal::orientation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.StatePoint)
  return target;
}

size_t StatePoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.StatePoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .osi3.Timestamp timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

    // optional .osi3.Vector3d position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .osi3.Orientation3d orientation = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.orientation_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatePoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatePoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatePoint::GetClassData() const { return &_class_data_; }


void StatePoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatePoint*>(&to_msg);
  auto& from = static_cast<const StatePoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.StatePoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timestamp()->::osi3::Timestamp::MergeFrom(
          from._internal_timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_position()->::osi3::Vector3d::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_orientation()->::osi3::Orientation3d::MergeFrom(
          from._internal_orientation());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatePoint::CopyFrom(const StatePoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.StatePoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatePoint::IsInitialized() const {
  return true;
}

void StatePoint::InternalSwap(StatePoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatePoint, _impl_.orientation_)
      + sizeof(StatePoint::_impl_.orientation_)
      - PROTOBUF_FIELD_OFFSET(StatePoint, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatePoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[12]);
}

// ===================================================================

class WavelengthData::_Internal {
 public:
  using HasBits = decltype(std::declval<WavelengthData>()._impl_._has_bits_);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_samples_number(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

WavelengthData::WavelengthData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.WavelengthData)
}
WavelengthData::WavelengthData(const WavelengthData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WavelengthData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){}
    , decltype(_impl_.end_){}
    , decltype(_impl_.samples_number_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_, &from._impl_.start_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.samples_number_) -
    reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.samples_number_));
  // @@protoc_insertion_point(copy_constructor:osi3.WavelengthData)
}

inline void WavelengthData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){0}
    , decltype(_impl_.end_){0}
    , decltype(_impl_.samples_number_){0}
  };
}

WavelengthData::~WavelengthData() {
  // @@protoc_insertion_point(destructor:osi3.WavelengthData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WavelengthData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WavelengthData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WavelengthData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.WavelengthData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.start_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.samples_number_) -
        reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.samples_number_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WavelengthData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double samples_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_samples_number(&has_bits);
          _impl_.samples_number_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WavelengthData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.WavelengthData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double start = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_start(), target);
  }

  // optional double end = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_end(), target);
  }

  // optional double samples_number = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_samples_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.WavelengthData)
  return target;
}

size_t WavelengthData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.WavelengthData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double start = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double end = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double samples_number = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WavelengthData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WavelengthData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WavelengthData::GetClassData() const { return &_class_data_; }


void WavelengthData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WavelengthData*>(&to_msg);
  auto& from = static_cast<const WavelengthData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.WavelengthData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.samples_number_ = from._impl_.samples_number_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WavelengthData::CopyFrom(const WavelengthData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.WavelengthData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WavelengthData::IsInitialized() const {
  return true;
}

void WavelengthData::InternalSwap(WavelengthData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WavelengthData, _impl_.samples_number_)
      + sizeof(WavelengthData::_impl_.samples_number_)
      - PROTOBUF_FIELD_OFFSET(WavelengthData, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WavelengthData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[13]);
}

// ===================================================================

class SpatialSignalStrength::_Internal {
 public:
  using HasBits = decltype(std::declval<SpatialSignalStrength>()._impl_._has_bits_);
  static void set_has_horizontal_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vertical_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signal_strength(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SpatialSignalStrength::SpatialSignalStrength(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.SpatialSignalStrength)
}
SpatialSignalStrength::SpatialSignalStrength(const SpatialSignalStrength& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpatialSignalStrength* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.horizontal_angle_){}
    , decltype(_impl_.vertical_angle_){}
    , decltype(_impl_.signal_strength_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.horizontal_angle_, &from._impl_.horizontal_angle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.signal_strength_) -
    reinterpret_cast<char*>(&_impl_.horizontal_angle_)) + sizeof(_impl_.signal_strength_));
  // @@protoc_insertion_point(copy_constructor:osi3.SpatialSignalStrength)
}

inline void SpatialSignalStrength::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.horizontal_angle_){0}
    , decltype(_impl_.vertical_angle_){0}
    , decltype(_impl_.signal_strength_){0}
  };
}

SpatialSignalStrength::~SpatialSignalStrength() {
  // @@protoc_insertion_point(destructor:osi3.SpatialSignalStrength)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpatialSignalStrength::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpatialSignalStrength::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpatialSignalStrength::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.SpatialSignalStrength)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.horizontal_angle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.signal_strength_) -
        reinterpret_cast<char*>(&_impl_.horizontal_angle_)) + sizeof(_impl_.signal_strength_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpatialSignalStrength::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double horizontal_angle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_horizontal_angle(&has_bits);
          _impl_.horizontal_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double vertical_angle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_vertical_angle(&has_bits);
          _impl_.vertical_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double signal_strength = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_signal_strength(&has_bits);
          _impl_.signal_strength_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpatialSignalStrength::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.SpatialSignalStrength)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double horizontal_angle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_horizontal_angle(), target);
  }

  // optional double vertical_angle = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_vertical_angle(), target);
  }

  // optional double signal_strength = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_signal_strength(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.SpatialSignalStrength)
  return target;
}

size_t SpatialSignalStrength::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.SpatialSignalStrength)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double horizontal_angle = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double vertical_angle = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double signal_strength = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpatialSignalStrength::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpatialSignalStrength::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpatialSignalStrength::GetClassData() const { return &_class_data_; }


void SpatialSignalStrength::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpatialSignalStrength*>(&to_msg);
  auto& from = static_cast<const SpatialSignalStrength&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.SpatialSignalStrength)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.horizontal_angle_ = from._impl_.horizontal_angle_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.vertical_angle_ = from._impl_.vertical_angle_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.signal_strength_ = from._impl_.signal_strength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpatialSignalStrength::CopyFrom(const SpatialSignalStrength& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.SpatialSignalStrength)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpatialSignalStrength::IsInitialized() const {
  return true;
}

void SpatialSignalStrength::InternalSwap(SpatialSignalStrength* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpatialSignalStrength, _impl_.signal_strength_)
      + sizeof(SpatialSignalStrength::_impl_.signal_strength_)
      - PROTOBUF_FIELD_OFFSET(SpatialSignalStrength, _impl_.horizontal_angle_)>(
          reinterpret_cast<char*>(&_impl_.horizontal_angle_),
          reinterpret_cast<char*>(&other->_impl_.horizontal_angle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpatialSignalStrength::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[14]);
}

// ===================================================================

class ColorDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<ColorDescription>()._impl_._has_bits_);
  static const ::osi3::ColorGrey& grey(const ColorDescription* msg);
  static void set_has_grey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::ColorRGB& rgb(const ColorDescription* msg);
  static void set_has_rgb(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::ColorRGBIR& rgbir(const ColorDescription* msg);
  static void set_has_rgbir(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::osi3::ColorHSV& hsv(const ColorDescription* msg);
  static void set_has_hsv(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::osi3::ColorLUV& luv(const ColorDescription* msg);
  static void set_has_luv(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::osi3::ColorCMYK& cmyk(const ColorDescription* msg);
  static void set_has_cmyk(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::osi3::ColorGrey&
ColorDescription::_Internal::grey(const ColorDescription* msg) {
  return *msg->_impl_.grey_;
}
const ::osi3::ColorRGB&
ColorDescription::_Internal::rgb(const ColorDescription* msg) {
  return *msg->_impl_.rgb_;
}
const ::osi3::ColorRGBIR&
ColorDescription::_Internal::rgbir(const ColorDescription* msg) {
  return *msg->_impl_.rgbir_;
}
const ::osi3::ColorHSV&
ColorDescription::_Internal::hsv(const ColorDescription* msg) {
  return *msg->_impl_.hsv_;
}
const ::osi3::ColorLUV&
ColorDescription::_Internal::luv(const ColorDescription* msg) {
  return *msg->_impl_.luv_;
}
const ::osi3::ColorCMYK&
ColorDescription::_Internal::cmyk(const ColorDescription* msg) {
  return *msg->_impl_.cmyk_;
}
ColorDescription::ColorDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.ColorDescription)
}
ColorDescription::ColorDescription(const ColorDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColorDescription* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grey_){nullptr}
    , decltype(_impl_.rgb_){nullptr}
    , decltype(_impl_.rgbir_){nullptr}
    , decltype(_impl_.hsv_){nullptr}
    , decltype(_impl_.luv_){nullptr}
    , decltype(_impl_.cmyk_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_grey()) {
    _this->_impl_.grey_ = new ::osi3::ColorGrey(*from._impl_.grey_);
  }
  if (from._internal_has_rgb()) {
    _this->_impl_.rgb_ = new ::osi3::ColorRGB(*from._impl_.rgb_);
  }
  if (from._internal_has_rgbir()) {
    _this->_impl_.rgbir_ = new ::osi3::ColorRGBIR(*from._impl_.rgbir_);
  }
  if (from._internal_has_hsv()) {
    _this->_impl_.hsv_ = new ::osi3::ColorHSV(*from._impl_.hsv_);
  }
  if (from._internal_has_luv()) {
    _this->_impl_.luv_ = new ::osi3::ColorLUV(*from._impl_.luv_);
  }
  if (from._internal_has_cmyk()) {
    _this->_impl_.cmyk_ = new ::osi3::ColorCMYK(*from._impl_.cmyk_);
  }
  // @@protoc_insertion_point(copy_constructor:osi3.ColorDescription)
}

inline void ColorDescription::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grey_){nullptr}
    , decltype(_impl_.rgb_){nullptr}
    , decltype(_impl_.rgbir_){nullptr}
    , decltype(_impl_.hsv_){nullptr}
    , decltype(_impl_.luv_){nullptr}
    , decltype(_impl_.cmyk_){nullptr}
  };
}

ColorDescription::~ColorDescription() {
  // @@protoc_insertion_point(destructor:osi3.ColorDescription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColorDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.grey_;
  if (this != internal_default_instance()) delete _impl_.rgb_;
  if (this != internal_default_instance()) delete _impl_.rgbir_;
  if (this != internal_default_instance()) delete _impl_.hsv_;
  if (this != internal_default_instance()) delete _impl_.luv_;
  if (this != internal_default_instance()) delete _impl_.cmyk_;
}

void ColorDescription::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColorDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.ColorDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.grey_ != nullptr);
      _impl_.grey_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.rgb_ != nullptr);
      _impl_.rgb_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.rgbir_ != nullptr);
      _impl_.rgbir_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.hsv_ != nullptr);
      _impl_.hsv_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.luv_ != nullptr);
      _impl_.luv_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.cmyk_ != nullptr);
      _impl_.cmyk_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColorDescription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.ColorGrey grey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_grey(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.ColorRGB rgb = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rgb(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.ColorRGBIR rgbir = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rgbir(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.ColorHSV hsv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_hsv(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.ColorLUV luv = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_luv(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.ColorCMYK cmyk = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_cmyk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColorDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.ColorDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.ColorGrey grey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::grey(this),
        _Internal::grey(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.ColorRGB rgb = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rgb(this),
        _Internal::rgb(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.ColorRGBIR rgbir = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::rgbir(this),
        _Internal::rgbir(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.ColorHSV hsv = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::hsv(this),
        _Internal::hsv(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.ColorLUV luv = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::luv(this),
        _Internal::luv(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.ColorCMYK cmyk = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::cmyk(this),
        _Internal::cmyk(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.ColorDescription)
  return target;
}

size_t ColorDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.ColorDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .osi3.ColorGrey grey = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.grey_);
    }

    // optional .osi3.ColorRGB rgb = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rgb_);
    }

    // optional .osi3.ColorRGBIR rgbir = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rgbir_);
    }

    // optional .osi3.ColorHSV hsv = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hsv_);
    }

    // optional .osi3.ColorLUV luv = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.luv_);
    }

    // optional .osi3.ColorCMYK cmyk = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cmyk_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColorDescription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColorDescription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColorDescription::GetClassData() const { return &_class_data_; }


void ColorDescription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColorDescription*>(&to_msg);
  auto& from = static_cast<const ColorDescription&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.ColorDescription)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_grey()->::osi3::ColorGrey::MergeFrom(
          from._internal_grey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rgb()->::osi3::ColorRGB::MergeFrom(
          from._internal_rgb());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_rgbir()->::osi3::ColorRGBIR::MergeFrom(
          from._internal_rgbir());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_hsv()->::osi3::ColorHSV::MergeFrom(
          from._internal_hsv());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_luv()->::osi3::ColorLUV::MergeFrom(
          from._internal_luv());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_cmyk()->::osi3::ColorCMYK::MergeFrom(
          from._internal_cmyk());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColorDescription::CopyFrom(const ColorDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.ColorDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorDescription::IsInitialized() const {
  return true;
}

void ColorDescription::InternalSwap(ColorDescription* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColorDescription, _impl_.cmyk_)
      + sizeof(ColorDescription::_impl_.cmyk_)
      - PROTOBUF_FIELD_OFFSET(ColorDescription, _impl_.grey_)>(
          reinterpret_cast<char*>(&_impl_.grey_),
          reinterpret_cast<char*>(&other->_impl_.grey_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ColorDescription::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[15]);
}

// ===================================================================

class ColorGrey::_Internal {
 public:
  using HasBits = decltype(std::declval<ColorGrey>()._impl_._has_bits_);
  static void set_has_grey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ColorGrey::ColorGrey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.ColorGrey)
}
ColorGrey::ColorGrey(const ColorGrey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColorGrey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grey_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.grey_ = from._impl_.grey_;
  // @@protoc_insertion_point(copy_constructor:osi3.ColorGrey)
}

inline void ColorGrey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grey_){0}
  };
}

ColorGrey::~ColorGrey() {
  // @@protoc_insertion_point(destructor:osi3.ColorGrey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColorGrey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ColorGrey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColorGrey::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.ColorGrey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.grey_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColorGrey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double grey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_grey(&has_bits);
          _impl_.grey_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColorGrey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.ColorGrey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double grey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_grey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.ColorGrey)
  return target;
}

size_t ColorGrey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.ColorGrey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional double grey = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColorGrey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColorGrey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColorGrey::GetClassData() const { return &_class_data_; }


void ColorGrey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColorGrey*>(&to_msg);
  auto& from = static_cast<const ColorGrey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.ColorGrey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_grey()) {
    _this->_internal_set_grey(from._internal_grey());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColorGrey::CopyFrom(const ColorGrey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.ColorGrey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorGrey::IsInitialized() const {
  return true;
}

void ColorGrey::InternalSwap(ColorGrey* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.grey_, other->_impl_.grey_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ColorGrey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[16]);
}

// ===================================================================

class ColorRGB::_Internal {
 public:
  using HasBits = decltype(std::declval<ColorRGB>()._impl_._has_bits_);
  static void set_has_red(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_green(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blue(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ColorRGB::ColorRGB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.ColorRGB)
}
ColorRGB::ColorRGB(const ColorRGB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColorRGB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.red_){}
    , decltype(_impl_.green_){}
    , decltype(_impl_.blue_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.red_, &from._impl_.red_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blue_) -
    reinterpret_cast<char*>(&_impl_.red_)) + sizeof(_impl_.blue_));
  // @@protoc_insertion_point(copy_constructor:osi3.ColorRGB)
}

inline void ColorRGB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.red_){0}
    , decltype(_impl_.green_){0}
    , decltype(_impl_.blue_){0}
  };
}

ColorRGB::~ColorRGB() {
  // @@protoc_insertion_point(destructor:osi3.ColorRGB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColorRGB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ColorRGB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColorRGB::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.ColorRGB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.red_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.blue_) -
        reinterpret_cast<char*>(&_impl_.red_)) + sizeof(_impl_.blue_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColorRGB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double red = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_red(&has_bits);
          _impl_.red_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double green = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_green(&has_bits);
          _impl_.green_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double blue = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_blue(&has_bits);
          _impl_.blue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColorRGB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.ColorRGB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double red = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_red(), target);
  }

  // optional double green = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_green(), target);
  }

  // optional double blue = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_blue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.ColorRGB)
  return target;
}

size_t ColorRGB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.ColorRGB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double red = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double green = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double blue = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColorRGB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColorRGB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColorRGB::GetClassData() const { return &_class_data_; }


void ColorRGB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColorRGB*>(&to_msg);
  auto& from = static_cast<const ColorRGB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.ColorRGB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.red_ = from._impl_.red_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.green_ = from._impl_.green_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.blue_ = from._impl_.blue_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColorRGB::CopyFrom(const ColorRGB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.ColorRGB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorRGB::IsInitialized() const {
  return true;
}

void ColorRGB::InternalSwap(ColorRGB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColorRGB, _impl_.blue_)
      + sizeof(ColorRGB::_impl_.blue_)
      - PROTOBUF_FIELD_OFFSET(ColorRGB, _impl_.red_)>(
          reinterpret_cast<char*>(&_impl_.red_),
          reinterpret_cast<char*>(&other->_impl_.red_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ColorRGB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[17]);
}

// ===================================================================

class ColorRGBIR::_Internal {
 public:
  using HasBits = decltype(std::declval<ColorRGBIR>()._impl_._has_bits_);
  static void set_has_red(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_green(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blue(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_infrared(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ColorRGBIR::ColorRGBIR(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.ColorRGBIR)
}
ColorRGBIR::ColorRGBIR(const ColorRGBIR& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColorRGBIR* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.red_){}
    , decltype(_impl_.green_){}
    , decltype(_impl_.blue_){}
    , decltype(_impl_.infrared_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.red_, &from._impl_.red_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.infrared_) -
    reinterpret_cast<char*>(&_impl_.red_)) + sizeof(_impl_.infrared_));
  // @@protoc_insertion_point(copy_constructor:osi3.ColorRGBIR)
}

inline void ColorRGBIR::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.red_){0}
    , decltype(_impl_.green_){0}
    , decltype(_impl_.blue_){0}
    , decltype(_impl_.infrared_){0}
  };
}

ColorRGBIR::~ColorRGBIR() {
  // @@protoc_insertion_point(destructor:osi3.ColorRGBIR)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColorRGBIR::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ColorRGBIR::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColorRGBIR::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.ColorRGBIR)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.red_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.infrared_) -
        reinterpret_cast<char*>(&_impl_.red_)) + sizeof(_impl_.infrared_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColorRGBIR::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double red = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_red(&has_bits);
          _impl_.red_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double green = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_green(&has_bits);
          _impl_.green_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double blue = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_blue(&has_bits);
          _impl_.blue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double infrared = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_infrared(&has_bits);
          _impl_.infrared_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColorRGBIR::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.ColorRGBIR)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double red = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_red(), target);
  }

  // optional double green = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_green(), target);
  }

  // optional double blue = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_blue(), target);
  }

  // optional double infrared = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_infrared(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.ColorRGBIR)
  return target;
}

size_t ColorRGBIR::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.ColorRGBIR)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional double red = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double green = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double blue = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double infrared = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColorRGBIR::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColorRGBIR::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColorRGBIR::GetClassData() const { return &_class_data_; }


void ColorRGBIR::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColorRGBIR*>(&to_msg);
  auto& from = static_cast<const ColorRGBIR&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.ColorRGBIR)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.red_ = from._impl_.red_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.green_ = from._impl_.green_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.blue_ = from._impl_.blue_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.infrared_ = from._impl_.infrared_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColorRGBIR::CopyFrom(const ColorRGBIR& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.ColorRGBIR)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorRGBIR::IsInitialized() const {
  return true;
}

void ColorRGBIR::InternalSwap(ColorRGBIR* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColorRGBIR, _impl_.infrared_)
      + sizeof(ColorRGBIR::_impl_.infrared_)
      - PROTOBUF_FIELD_OFFSET(ColorRGBIR, _impl_.red_)>(
          reinterpret_cast<char*>(&_impl_.red_),
          reinterpret_cast<char*>(&other->_impl_.red_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ColorRGBIR::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[18]);
}

// ===================================================================

class ColorHSV::_Internal {
 public:
  using HasBits = decltype(std::declval<ColorHSV>()._impl_._has_bits_);
  static void set_has_hue(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_saturation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ColorHSV::ColorHSV(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.ColorHSV)
}
ColorHSV::ColorHSV(const ColorHSV& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColorHSV* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hue_){}
    , decltype(_impl_.saturation_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hue_, &from._impl_.hue_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.hue_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:osi3.ColorHSV)
}

inline void ColorHSV::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hue_){0}
    , decltype(_impl_.saturation_){0}
    , decltype(_impl_.value_){0}
  };
}

ColorHSV::~ColorHSV() {
  // @@protoc_insertion_point(destructor:osi3.ColorHSV)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColorHSV::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ColorHSV::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColorHSV::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.ColorHSV)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.hue_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.value_) -
        reinterpret_cast<char*>(&_impl_.hue_)) + sizeof(_impl_.value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColorHSV::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double hue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_hue(&has_bits);
          _impl_.hue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double saturation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_saturation(&has_bits);
          _impl_.saturation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColorHSV::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.ColorHSV)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double hue = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_hue(), target);
  }

  // optional double saturation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_saturation(), target);
  }

  // optional double value = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.ColorHSV)
  return target;
}

size_t ColorHSV::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.ColorHSV)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double hue = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double saturation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double value = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColorHSV::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColorHSV::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColorHSV::GetClassData() const { return &_class_data_; }


void ColorHSV::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColorHSV*>(&to_msg);
  auto& from = static_cast<const ColorHSV&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.ColorHSV)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hue_ = from._impl_.hue_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.saturation_ = from._impl_.saturation_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColorHSV::CopyFrom(const ColorHSV& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.ColorHSV)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorHSV::IsInitialized() const {
  return true;
}

void ColorHSV::InternalSwap(ColorHSV* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColorHSV, _impl_.value_)
      + sizeof(ColorHSV::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(ColorHSV, _impl_.hue_)>(
          reinterpret_cast<char*>(&_impl_.hue_),
          reinterpret_cast<char*>(&other->_impl_.hue_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ColorHSV::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[19]);
}

// ===================================================================

class ColorLUV::_Internal {
 public:
  using HasBits = decltype(std::declval<ColorLUV>()._impl_._has_bits_);
  static void set_has_luminance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_u(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_v(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ColorLUV::ColorLUV(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.ColorLUV)
}
ColorLUV::ColorLUV(const ColorLUV& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColorLUV* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.luminance_){}
    , decltype(_impl_.u_){}
    , decltype(_impl_.v_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.luminance_, &from._impl_.luminance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.v_) -
    reinterpret_cast<char*>(&_impl_.luminance_)) + sizeof(_impl_.v_));
  // @@protoc_insertion_point(copy_constructor:osi3.ColorLUV)
}

inline void ColorLUV::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.luminance_){0}
    , decltype(_impl_.u_){0}
    , decltype(_impl_.v_){0}
  };
}

ColorLUV::~ColorLUV() {
  // @@protoc_insertion_point(destructor:osi3.ColorLUV)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColorLUV::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ColorLUV::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColorLUV::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.ColorLUV)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.luminance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.v_) -
        reinterpret_cast<char*>(&_impl_.luminance_)) + sizeof(_impl_.v_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColorLUV::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double luminance = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_luminance(&has_bits);
          _impl_.luminance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double u = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_u(&has_bits);
          _impl_.u_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double v = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_v(&has_bits);
          _impl_.v_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColorLUV::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.ColorLUV)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double luminance = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_luminance(), target);
  }

  // optional double u = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_u(), target);
  }

  // optional double v = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_v(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.ColorLUV)
  return target;
}

size_t ColorLUV::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.ColorLUV)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double luminance = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double u = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double v = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColorLUV::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColorLUV::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColorLUV::GetClassData() const { return &_class_data_; }


void ColorLUV::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColorLUV*>(&to_msg);
  auto& from = static_cast<const ColorLUV&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.ColorLUV)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.luminance_ = from._impl_.luminance_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.u_ = from._impl_.u_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.v_ = from._impl_.v_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColorLUV::CopyFrom(const ColorLUV& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.ColorLUV)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorLUV::IsInitialized() const {
  return true;
}

void ColorLUV::InternalSwap(ColorLUV* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColorLUV, _impl_.v_)
      + sizeof(ColorLUV::_impl_.v_)
      - PROTOBUF_FIELD_OFFSET(ColorLUV, _impl_.luminance_)>(
          reinterpret_cast<char*>(&_impl_.luminance_),
          reinterpret_cast<char*>(&other->_impl_.luminance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ColorLUV::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[20]);
}

// ===================================================================

class ColorCMYK::_Internal {
 public:
  using HasBits = decltype(std::declval<ColorCMYK>()._impl_._has_bits_);
  static void set_has_cyan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_magenta(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_yellow(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ColorCMYK::ColorCMYK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.ColorCMYK)
}
ColorCMYK::ColorCMYK(const ColorCMYK& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColorCMYK* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cyan_){}
    , decltype(_impl_.magenta_){}
    , decltype(_impl_.yellow_){}
    , decltype(_impl_.key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.cyan_, &from._impl_.cyan_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.key_) -
    reinterpret_cast<char*>(&_impl_.cyan_)) + sizeof(_impl_.key_));
  // @@protoc_insertion_point(copy_constructor:osi3.ColorCMYK)
}

inline void ColorCMYK::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cyan_){0}
    , decltype(_impl_.magenta_){0}
    , decltype(_impl_.yellow_){0}
    , decltype(_impl_.key_){0}
  };
}

ColorCMYK::~ColorCMYK() {
  // @@protoc_insertion_point(destructor:osi3.ColorCMYK)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColorCMYK::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ColorCMYK::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColorCMYK::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.ColorCMYK)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.cyan_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.key_) -
        reinterpret_cast<char*>(&_impl_.cyan_)) + sizeof(_impl_.key_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColorCMYK::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double cyan = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_cyan(&has_bits);
          _impl_.cyan_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double magenta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_magenta(&has_bits);
          _impl_.magenta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double yellow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_yellow(&has_bits);
          _impl_.yellow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_key(&has_bits);
          _impl_.key_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColorCMYK::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.ColorCMYK)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double cyan = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_cyan(), target);
  }

  // optional double magenta = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_magenta(), target);
  }

  // optional double yellow = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_yellow(), target);
  }

  // optional double key = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.ColorCMYK)
  return target;
}

size_t ColorCMYK::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.ColorCMYK)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional double cyan = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double magenta = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double yellow = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double key = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColorCMYK::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColorCMYK::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColorCMYK::GetClassData() const { return &_class_data_; }


void ColorCMYK::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColorCMYK*>(&to_msg);
  auto& from = static_cast<const ColorCMYK&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.ColorCMYK)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.cyan_ = from._impl_.cyan_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.magenta_ = from._impl_.magenta_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.yellow_ = from._impl_.yellow_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.key_ = from._impl_.key_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColorCMYK::CopyFrom(const ColorCMYK& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.ColorCMYK)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorCMYK::IsInitialized() const {
  return true;
}

void ColorCMYK::InternalSwap(ColorCMYK* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColorCMYK, _impl_.key_)
      + sizeof(ColorCMYK::_impl_.key_)
      - PROTOBUF_FIELD_OFFSET(ColorCMYK, _impl_.cyan_)>(
          reinterpret_cast<char*>(&_impl_.cyan_),
          reinterpret_cast<char*>(&other->_impl_.cyan_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ColorCMYK::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[21]);
}

// ===================================================================

class Pedalry::_Internal {
 public:
  using HasBits = decltype(std::declval<Pedalry>()._impl_._has_bits_);
  static void set_has_pedal_position_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pedal_position_brake(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pedal_position_clutch(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Pedalry::Pedalry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.Pedalry)
}
Pedalry::Pedalry(const Pedalry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Pedalry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pedal_position_acceleration_){}
    , decltype(_impl_.pedal_position_brake_){}
    , decltype(_impl_.pedal_position_clutch_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.pedal_position_acceleration_, &from._impl_.pedal_position_acceleration_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pedal_position_clutch_) -
    reinterpret_cast<char*>(&_impl_.pedal_position_acceleration_)) + sizeof(_impl_.pedal_position_clutch_));
  // @@protoc_insertion_point(copy_constructor:osi3.Pedalry)
}

inline void Pedalry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pedal_position_acceleration_){0}
    , decltype(_impl_.pedal_position_brake_){0}
    , decltype(_impl_.pedal_position_clutch_){0}
  };
}

Pedalry::~Pedalry() {
  // @@protoc_insertion_point(destructor:osi3.Pedalry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Pedalry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Pedalry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Pedalry::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Pedalry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.pedal_position_acceleration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pedal_position_clutch_) -
        reinterpret_cast<char*>(&_impl_.pedal_position_acceleration_)) + sizeof(_impl_.pedal_position_clutch_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Pedalry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double pedal_position_acceleration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_pedal_position_acceleration(&has_bits);
          _impl_.pedal_position_acceleration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double pedal_position_brake = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_pedal_position_brake(&has_bits);
          _impl_.pedal_position_brake_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double pedal_position_clutch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_pedal_position_clutch(&has_bits);
          _impl_.pedal_position_clutch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Pedalry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Pedalry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double pedal_position_acceleration = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_pedal_position_acceleration(), target);
  }

  // optional double pedal_position_brake = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_pedal_position_brake(), target);
  }

  // optional double pedal_position_clutch = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_pedal_position_clutch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Pedalry)
  return target;
}

size_t Pedalry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Pedalry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double pedal_position_acceleration = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double pedal_position_brake = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double pedal_position_clutch = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Pedalry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Pedalry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Pedalry::GetClassData() const { return &_class_data_; }


void Pedalry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Pedalry*>(&to_msg);
  auto& from = static_cast<const Pedalry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Pedalry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pedal_position_acceleration_ = from._impl_.pedal_position_acceleration_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pedal_position_brake_ = from._impl_.pedal_position_brake_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pedal_position_clutch_ = from._impl_.pedal_position_clutch_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Pedalry::CopyFrom(const Pedalry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Pedalry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pedalry::IsInitialized() const {
  return true;
}

void Pedalry::InternalSwap(Pedalry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Pedalry, _impl_.pedal_position_clutch_)
      + sizeof(Pedalry::_impl_.pedal_position_clutch_)
      - PROTOBUF_FIELD_OFFSET(Pedalry, _impl_.pedal_position_acceleration_)>(
          reinterpret_cast<char*>(&_impl_.pedal_position_acceleration_),
          reinterpret_cast<char*>(&other->_impl_.pedal_position_acceleration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Pedalry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[22]);
}

// ===================================================================

class VehicleSteeringWheel::_Internal {
 public:
  using HasBits = decltype(std::declval<VehicleSteeringWheel>()._impl_._has_bits_);
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_angular_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_torque(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

VehicleSteeringWheel::VehicleSteeringWheel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.VehicleSteeringWheel)
}
VehicleSteeringWheel::VehicleSteeringWheel(const VehicleSteeringWheel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VehicleSteeringWheel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){}
    , decltype(_impl_.angular_speed_){}
    , decltype(_impl_.torque_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.angle_, &from._impl_.angle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.torque_) -
    reinterpret_cast<char*>(&_impl_.angle_)) + sizeof(_impl_.torque_));
  // @@protoc_insertion_point(copy_constructor:osi3.VehicleSteeringWheel)
}

inline void VehicleSteeringWheel::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){0}
    , decltype(_impl_.angular_speed_){0}
    , decltype(_impl_.torque_){0}
  };
}

VehicleSteeringWheel::~VehicleSteeringWheel() {
  // @@protoc_insertion_point(destructor:osi3.VehicleSteeringWheel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VehicleSteeringWheel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VehicleSteeringWheel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VehicleSteeringWheel::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.VehicleSteeringWheel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.angle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.torque_) -
        reinterpret_cast<char*>(&_impl_.angle_)) + sizeof(_impl_.torque_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VehicleSteeringWheel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double angle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_angle(&has_bits);
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double angular_speed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_angular_speed(&has_bits);
          _impl_.angular_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double torque = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_torque(&has_bits);
          _impl_.torque_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VehicleSteeringWheel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.VehicleSteeringWheel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double angle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_angle(), target);
  }

  // optional double angular_speed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_angular_speed(), target);
  }

  // optional double torque = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_torque(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.VehicleSteeringWheel)
  return target;
}

size_t VehicleSteeringWheel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.VehicleSteeringWheel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double angle = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double angular_speed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double torque = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VehicleSteeringWheel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VehicleSteeringWheel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VehicleSteeringWheel::GetClassData() const { return &_class_data_; }


void VehicleSteeringWheel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VehicleSteeringWheel*>(&to_msg);
  auto& from = static_cast<const VehicleSteeringWheel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.VehicleSteeringWheel)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.angle_ = from._impl_.angle_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.angular_speed_ = from._impl_.angular_speed_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.torque_ = from._impl_.torque_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VehicleSteeringWheel::CopyFrom(const VehicleSteeringWheel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.VehicleSteeringWheel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehicleSteeringWheel::IsInitialized() const {
  return true;
}

void VehicleSteeringWheel::InternalSwap(VehicleSteeringWheel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VehicleSteeringWheel, _impl_.torque_)
      + sizeof(VehicleSteeringWheel::_impl_.torque_)
      - PROTOBUF_FIELD_OFFSET(VehicleSteeringWheel, _impl_.angle_)>(
          reinterpret_cast<char*>(&_impl_.angle_),
          reinterpret_cast<char*>(&other->_impl_.angle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VehicleSteeringWheel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[23]);
}

// ===================================================================

class GeodeticPosition::_Internal {
 public:
  using HasBits = decltype(std::declval<GeodeticPosition>()._impl_._has_bits_);
  static void set_has_longitude(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latitude(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_altitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GeodeticPosition::GeodeticPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.GeodeticPosition)
}
GeodeticPosition::GeodeticPosition(const GeodeticPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GeodeticPosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.longitude_){}
    , decltype(_impl_.latitude_){}
    , decltype(_impl_.altitude_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.longitude_, &from._impl_.longitude_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.altitude_) -
    reinterpret_cast<char*>(&_impl_.longitude_)) + sizeof(_impl_.altitude_));
  // @@protoc_insertion_point(copy_constructor:osi3.GeodeticPosition)
}

inline void GeodeticPosition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.longitude_){0}
    , decltype(_impl_.latitude_){0}
    , decltype(_impl_.altitude_){0}
  };
}

GeodeticPosition::~GeodeticPosition() {
  // @@protoc_insertion_point(destructor:osi3.GeodeticPosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeodeticPosition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GeodeticPosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GeodeticPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.GeodeticPosition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.longitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.altitude_) -
        reinterpret_cast<char*>(&_impl_.longitude_)) + sizeof(_impl_.altitude_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeodeticPosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double longitude = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_longitude(&has_bits);
          _impl_.longitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double latitude = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_latitude(&has_bits);
          _impl_.latitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double altitude = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_altitude(&has_bits);
          _impl_.altitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GeodeticPosition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.GeodeticPosition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double longitude = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_longitude(), target);
  }

  // optional double latitude = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_latitude(), target);
  }

  // optional double altitude = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_altitude(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.GeodeticPosition)
  return target;
}

size_t GeodeticPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.GeodeticPosition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double longitude = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double latitude = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double altitude = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeodeticPosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GeodeticPosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeodeticPosition::GetClassData() const { return &_class_data_; }


void GeodeticPosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GeodeticPosition*>(&to_msg);
  auto& from = static_cast<const GeodeticPosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.GeodeticPosition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.longitude_ = from._impl_.longitude_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.latitude_ = from._impl_.latitude_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.altitude_ = from._impl_.altitude_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeodeticPosition::CopyFrom(const GeodeticPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.GeodeticPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeodeticPosition::IsInitialized() const {
  return true;
}

void GeodeticPosition::InternalSwap(GeodeticPosition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeodeticPosition, _impl_.altitude_)
      + sizeof(GeodeticPosition::_impl_.altitude_)
      - PROTOBUF_FIELD_OFFSET(GeodeticPosition, _impl_.longitude_)>(
          reinterpret_cast<char*>(&_impl_.longitude_),
          reinterpret_cast<char*>(&other->_impl_.longitude_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GeodeticPosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[24]);
}

// ===================================================================

class KeyValuePair::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyValuePair>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KeyValuePair::KeyValuePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.KeyValuePair)
}
KeyValuePair::KeyValuePair(const KeyValuePair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyValuePair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:osi3.KeyValuePair)
}

inline void KeyValuePair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyValuePair::~KeyValuePair() {
  // @@protoc_insertion_point(destructor:osi3.KeyValuePair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyValuePair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
}

void KeyValuePair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyValuePair::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.KeyValuePair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyValuePair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "osi3.KeyValuePair.key");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "osi3.KeyValuePair.value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyValuePair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.KeyValuePair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "osi3.KeyValuePair.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "osi3.KeyValuePair.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.KeyValuePair)
  return target;
}

size_t KeyValuePair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.KeyValuePair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyValuePair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyValuePair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyValuePair::GetClassData() const { return &_class_data_; }


void KeyValuePair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyValuePair*>(&to_msg);
  auto& from = static_cast<const KeyValuePair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.KeyValuePair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyValuePair::CopyFrom(const KeyValuePair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.KeyValuePair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyValuePair::IsInitialized() const {
  return true;
}

void KeyValuePair::InternalSwap(KeyValuePair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyValuePair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5fcommon_2eproto_getter, &descriptor_table_osi_5fcommon_2eproto_once,
      file_level_metadata_osi_5fcommon_2eproto[25]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace osi3
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::osi3::Vector3d*
Arena::CreateMaybeMessage< ::osi3::Vector3d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::Vector3d >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::Vector2d*
Arena::CreateMaybeMessage< ::osi3::Vector2d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::Vector2d >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::Timestamp*
Arena::CreateMaybeMessage< ::osi3::Timestamp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::Timestamp >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::Dimension3d*
Arena::CreateMaybeMessage< ::osi3::Dimension3d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::Dimension3d >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::Orientation3d*
Arena::CreateMaybeMessage< ::osi3::Orientation3d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::Orientation3d >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::Identifier*
Arena::CreateMaybeMessage< ::osi3::Identifier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::Identifier >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::ExternalReference*
Arena::CreateMaybeMessage< ::osi3::ExternalReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::ExternalReference >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::MountingPosition*
Arena::CreateMaybeMessage< ::osi3::MountingPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::MountingPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::Spherical3d*
Arena::CreateMaybeMessage< ::osi3::Spherical3d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::Spherical3d >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::LogicalLaneAssignment*
Arena::CreateMaybeMessage< ::osi3::LogicalLaneAssignment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::LogicalLaneAssignment >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::BaseStationary*
Arena::CreateMaybeMessage< ::osi3::BaseStationary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::BaseStationary >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::BaseMoving*
Arena::CreateMaybeMessage< ::osi3::BaseMoving >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::BaseMoving >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::StatePoint*
Arena::CreateMaybeMessage< ::osi3::StatePoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::StatePoint >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::WavelengthData*
Arena::CreateMaybeMessage< ::osi3::WavelengthData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::WavelengthData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::SpatialSignalStrength*
Arena::CreateMaybeMessage< ::osi3::SpatialSignalStrength >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::SpatialSignalStrength >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::ColorDescription*
Arena::CreateMaybeMessage< ::osi3::ColorDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::ColorDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::ColorGrey*
Arena::CreateMaybeMessage< ::osi3::ColorGrey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::ColorGrey >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::ColorRGB*
Arena::CreateMaybeMessage< ::osi3::ColorRGB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::ColorRGB >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::ColorRGBIR*
Arena::CreateMaybeMessage< ::osi3::ColorRGBIR >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::ColorRGBIR >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::ColorHSV*
Arena::CreateMaybeMessage< ::osi3::ColorHSV >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::ColorHSV >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::ColorLUV*
Arena::CreateMaybeMessage< ::osi3::ColorLUV >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::ColorLUV >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::ColorCMYK*
Arena::CreateMaybeMessage< ::osi3::ColorCMYK >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::ColorCMYK >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::Pedalry*
Arena::CreateMaybeMessage< ::osi3::Pedalry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::Pedalry >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::VehicleSteeringWheel*
Arena::CreateMaybeMessage< ::osi3::VehicleSteeringWheel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::VehicleSteeringWheel >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::GeodeticPosition*
Arena::CreateMaybeMessage< ::osi3::GeodeticPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::GeodeticPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::KeyValuePair*
Arena::CreateMaybeMessage< ::osi3::KeyValuePair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::KeyValuePair >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
