// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osi_featuredata.proto

#include "osi_featuredata.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace osi3 {
PROTOBUF_CONSTEXPR FeatureData::FeatureData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.radar_sensor_)*/{}
  , /*decltype(_impl_.lidar_sensor_)*/{}
  , /*decltype(_impl_.ultrasonic_sensor_)*/{}
  , /*decltype(_impl_.camera_sensor_)*/{}
  , /*decltype(_impl_.version_)*/nullptr} {}
struct FeatureDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeatureDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeatureDataDefaultTypeInternal() {}
  union {
    FeatureData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeatureDataDefaultTypeInternal _FeatureData_default_instance_;
PROTOBUF_CONSTEXPR SensorDetectionHeader::SensorDetectionHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.measurement_time_)*/nullptr
  , /*decltype(_impl_.mounting_position_)*/nullptr
  , /*decltype(_impl_.mounting_position_rmse_)*/nullptr
  , /*decltype(_impl_.sensor_id_)*/nullptr
  , /*decltype(_impl_.cycle_counter_)*/uint64_t{0u}
  , /*decltype(_impl_.data_qualifier_)*/0
  , /*decltype(_impl_.number_of_valid_detections_)*/0u
  , /*decltype(_impl_.extended_qualifier_)*/0} {}
struct SensorDetectionHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SensorDetectionHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SensorDetectionHeaderDefaultTypeInternal() {}
  union {
    SensorDetectionHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SensorDetectionHeaderDefaultTypeInternal _SensorDetectionHeader_default_instance_;
PROTOBUF_CONSTEXPR RadarDetectionData::RadarDetectionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.detection_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct RadarDetectionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RadarDetectionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RadarDetectionDataDefaultTypeInternal() {}
  union {
    RadarDetectionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RadarDetectionDataDefaultTypeInternal _RadarDetectionData_default_instance_;
PROTOBUF_CONSTEXPR RadarDetection::RadarDetection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_id_)*/nullptr
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.position_rmse_)*/nullptr
  , /*decltype(_impl_.ambiguity_id_)*/nullptr
  , /*decltype(_impl_.existence_probability_)*/0
  , /*decltype(_impl_.radial_velocity_)*/0
  , /*decltype(_impl_.radial_velocity_rmse_)*/0
  , /*decltype(_impl_.rcs_)*/0
  , /*decltype(_impl_.snr_)*/0
  , /*decltype(_impl_.point_target_probability_)*/0
  , /*decltype(_impl_.classification_)*/0} {}
struct RadarDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RadarDetectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RadarDetectionDefaultTypeInternal() {}
  union {
    RadarDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RadarDetectionDefaultTypeInternal _RadarDetection_default_instance_;
PROTOBUF_CONSTEXPR LidarDetectionData::LidarDetectionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.detection_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct LidarDetectionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LidarDetectionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LidarDetectionDataDefaultTypeInternal() {}
  union {
    LidarDetectionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LidarDetectionDataDefaultTypeInternal _LidarDetectionData_default_instance_;
PROTOBUF_CONSTEXPR LidarDetection::LidarDetection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_id_)*/nullptr
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.position_rmse_)*/nullptr
  , /*decltype(_impl_.existence_probability_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.height_rmse_)*/0
  , /*decltype(_impl_.intensity_)*/0
  , /*decltype(_impl_.free_space_probability_)*/0
  , /*decltype(_impl_.reflectivity_)*/0
  , /*decltype(_impl_.echo_pulse_width_)*/0
  , /*decltype(_impl_.classification_)*/0} {}
struct LidarDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LidarDetectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LidarDetectionDefaultTypeInternal() {}
  union {
    LidarDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LidarDetectionDefaultTypeInternal _LidarDetection_default_instance_;
PROTOBUF_CONSTEXPR UltrasonicDetectionSpecificHeader::UltrasonicDetectionSpecificHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.max_range_)*/0
  , /*decltype(_impl_.number_of_valid_indirect_detections_)*/0u} {}
struct UltrasonicDetectionSpecificHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UltrasonicDetectionSpecificHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UltrasonicDetectionSpecificHeaderDefaultTypeInternal() {}
  union {
    UltrasonicDetectionSpecificHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UltrasonicDetectionSpecificHeaderDefaultTypeInternal _UltrasonicDetectionSpecificHeader_default_instance_;
PROTOBUF_CONSTEXPR UltrasonicDetectionData::UltrasonicDetectionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.detection_)*/{}
  , /*decltype(_impl_.indirect_detection_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.specific_header_)*/nullptr} {}
struct UltrasonicDetectionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UltrasonicDetectionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UltrasonicDetectionDataDefaultTypeInternal() {}
  union {
    UltrasonicDetectionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UltrasonicDetectionDataDefaultTypeInternal _UltrasonicDetectionData_default_instance_;
PROTOBUF_CONSTEXPR UltrasonicDetection::UltrasonicDetection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_id_)*/nullptr
  , /*decltype(_impl_.existence_probability_)*/0
  , /*decltype(_impl_.distance_)*/0} {}
struct UltrasonicDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UltrasonicDetectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UltrasonicDetectionDefaultTypeInternal() {}
  union {
    UltrasonicDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UltrasonicDetectionDefaultTypeInternal _UltrasonicDetection_default_instance_;
PROTOBUF_CONSTEXPR UltrasonicIndirectDetection::UltrasonicIndirectDetection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_id_)*/nullptr
  , /*decltype(_impl_.receiver_id_)*/nullptr
  , /*decltype(_impl_.receiver_origin_)*/nullptr
  , /*decltype(_impl_.existence_probability_)*/0
  , /*decltype(_impl_.ellipsoid_radial_)*/0
  , /*decltype(_impl_.ellipsoid_axial_)*/0} {}
struct UltrasonicIndirectDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UltrasonicIndirectDetectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UltrasonicIndirectDetectionDefaultTypeInternal() {}
  union {
    UltrasonicIndirectDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UltrasonicIndirectDetectionDefaultTypeInternal _UltrasonicIndirectDetection_default_instance_;
PROTOBUF_CONSTEXPR CameraDetectionSpecificHeader::CameraDetectionSpecificHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.number_of_valid_points_)*/0u} {}
struct CameraDetectionSpecificHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CameraDetectionSpecificHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CameraDetectionSpecificHeaderDefaultTypeInternal() {}
  union {
    CameraDetectionSpecificHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CameraDetectionSpecificHeaderDefaultTypeInternal _CameraDetectionSpecificHeader_default_instance_;
PROTOBUF_CONSTEXPR CameraDetectionData::CameraDetectionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.detection_)*/{}
  , /*decltype(_impl_.point_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.specific_header_)*/nullptr} {}
struct CameraDetectionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CameraDetectionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CameraDetectionDataDefaultTypeInternal() {}
  union {
    CameraDetectionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CameraDetectionDataDefaultTypeInternal _CameraDetectionData_default_instance_;
PROTOBUF_CONSTEXPR CameraDetection::CameraDetection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_id_)*/nullptr
  , /*decltype(_impl_.time_difference_)*/nullptr
  , /*decltype(_impl_.ambiguity_id_)*/nullptr
  , /*decltype(_impl_.color_description_)*/nullptr
  , /*decltype(_impl_.existence_probability_)*/0
  , /*decltype(_impl_.image_shape_type_)*/0
  , /*decltype(_impl_.shape_classification_background_)*/false
  , /*decltype(_impl_.shape_classification_foreground_)*/false
  , /*decltype(_impl_.shape_classification_flat_)*/false
  , /*decltype(_impl_.shape_classification_upright_)*/false
  , /*decltype(_impl_.shape_classification_ground_)*/false
  , /*decltype(_impl_.shape_classification_sky_)*/false
  , /*decltype(_impl_.shape_classification_vegetation_)*/false
  , /*decltype(_impl_.shape_classification_road_)*/false
  , /*decltype(_impl_.shape_classification_non_driving_lane_)*/false
  , /*decltype(_impl_.shape_classification_non_road_)*/false
  , /*decltype(_impl_.shape_classification_stationary_object_)*/false
  , /*decltype(_impl_.shape_classification_moving_object_)*/false
  , /*decltype(_impl_.shape_classification_landmark_)*/false
  , /*decltype(_impl_.shape_classification_traffic_sign_)*/false
  , /*decltype(_impl_.shape_classification_traffic_light_)*/false
  , /*decltype(_impl_.shape_classification_road_marking_)*/false
  , /*decltype(_impl_.shape_classification_vehicle_)*/false
  , /*decltype(_impl_.shape_classification_pedestrian_)*/false
  , /*decltype(_impl_.shape_classification_animal_)*/false
  , /*decltype(_impl_.shape_classification_pedestrian_front_)*/false
  , /*decltype(_impl_.shape_classification_pedestrian_side_)*/false
  , /*decltype(_impl_.shape_classification_pedestrian_rear_)*/false
  , /*decltype(_impl_.color_)*/0
  , /*decltype(_impl_.shape_classification_probability_)*/0
  , /*decltype(_impl_.color_probability_)*/0
  , /*decltype(_impl_.first_point_index_)*/0u
  , /*decltype(_impl_.number_of_points_)*/0u} {}
struct CameraDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CameraDetectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CameraDetectionDefaultTypeInternal() {}
  union {
    CameraDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CameraDetectionDefaultTypeInternal _CameraDetection_default_instance_;
PROTOBUF_CONSTEXPR CameraPoint::CameraPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.point_rmse_)*/nullptr
  , /*decltype(_impl_.existence_probability_)*/0} {}
struct CameraPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CameraPointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CameraPointDefaultTypeInternal() {}
  union {
    CameraPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CameraPointDefaultTypeInternal _CameraPoint_default_instance_;
}  // namespace osi3
static ::_pb::Metadata file_level_metadata_osi_5ffeaturedata_2eproto[14];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_osi_5ffeaturedata_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_osi_5ffeaturedata_2eproto = nullptr;

const uint32_t TableStruct_osi_5ffeaturedata_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_.radar_sensor_),
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_.lidar_sensor_),
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_.ultrasonic_sensor_),
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_.camera_sensor_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.measurement_time_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.cycle_counter_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.mounting_position_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.mounting_position_rmse_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.data_qualifier_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.number_of_valid_detections_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.sensor_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.extended_qualifier_),
  0,
  4,
  1,
  2,
  5,
  6,
  3,
  7,
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, _impl_.detection_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.object_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.position_rmse_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.radial_velocity_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.radial_velocity_rmse_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.rcs_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.snr_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.point_target_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.ambiguity_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.classification_),
  4,
  0,
  1,
  2,
  5,
  6,
  7,
  8,
  9,
  3,
  10,
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, _impl_.detection_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.object_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.position_rmse_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.height_rmse_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.intensity_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.free_space_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.classification_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.reflectivity_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.echo_pulse_width_),
  3,
  0,
  1,
  2,
  4,
  5,
  6,
  7,
  10,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, _impl_.max_range_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, _impl_.number_of_valid_indirect_detections_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _impl_.specific_header_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _impl_.detection_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _impl_.indirect_detection_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _impl_.existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _impl_.object_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _impl_.distance_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.object_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.ellipsoid_radial_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.ellipsoid_axial_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.receiver_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.receiver_origin_),
  3,
  0,
  4,
  5,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionSpecificHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionSpecificHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionSpecificHeader, _impl_.number_of_valid_points_),
  0,
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _impl_.specific_header_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _impl_.detection_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _impl_.point_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.object_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.time_difference_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.image_shape_type_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_background_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_foreground_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_flat_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_upright_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_ground_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_sky_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_vegetation_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_road_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_non_driving_lane_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_non_road_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_stationary_object_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_moving_object_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_landmark_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_traffic_sign_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_traffic_light_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_road_marking_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_vehicle_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_pedestrian_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_animal_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_pedestrian_front_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_pedestrian_side_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_pedestrian_rear_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.color_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.ambiguity_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.first_point_index_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.number_of_points_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.color_description_),
  4,
  0,
  1,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  29,
  28,
  30,
  2,
  31,
  32,
  3,
  PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _impl_.existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _impl_.point_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _impl_.point_rmse_),
  2,
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::osi3::FeatureData)},
  { 16, 30, -1, sizeof(::osi3::SensorDetectionHeader)},
  { 38, 46, -1, sizeof(::osi3::RadarDetectionData)},
  { 48, 65, -1, sizeof(::osi3::RadarDetection)},
  { 76, 84, -1, sizeof(::osi3::LidarDetectionData)},
  { 86, 103, -1, sizeof(::osi3::LidarDetection)},
  { 114, 122, -1, sizeof(::osi3::UltrasonicDetectionSpecificHeader)},
  { 124, 134, -1, sizeof(::osi3::UltrasonicDetectionData)},
  { 138, 147, -1, sizeof(::osi3::UltrasonicDetection)},
  { 150, 162, -1, sizeof(::osi3::UltrasonicIndirectDetection)},
  { 168, 175, -1, sizeof(::osi3::CameraDetectionSpecificHeader)},
  { 176, 186, -1, sizeof(::osi3::CameraDetectionData)},
  { 190, 229, -1, sizeof(::osi3::CameraDetection)},
  { 262, 271, -1, sizeof(::osi3::CameraPoint)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::osi3::_FeatureData_default_instance_._instance,
  &::osi3::_SensorDetectionHeader_default_instance_._instance,
  &::osi3::_RadarDetectionData_default_instance_._instance,
  &::osi3::_RadarDetection_default_instance_._instance,
  &::osi3::_LidarDetectionData_default_instance_._instance,
  &::osi3::_LidarDetection_default_instance_._instance,
  &::osi3::_UltrasonicDetectionSpecificHeader_default_instance_._instance,
  &::osi3::_UltrasonicDetectionData_default_instance_._instance,
  &::osi3::_UltrasonicDetection_default_instance_._instance,
  &::osi3::_UltrasonicIndirectDetection_default_instance_._instance,
  &::osi3::_CameraDetectionSpecificHeader_default_instance_._instance,
  &::osi3::_CameraDetectionData_default_instance_._instance,
  &::osi3::_CameraDetection_default_instance_._instance,
  &::osi3::_CameraPoint_default_instance_._instance,
};

const char descriptor_table_protodef_osi_5ffeaturedata_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025osi_featuredata.proto\022\004osi3\032\021osi_versi"
  "on.proto\032\020osi_common.proto\"\202\002\n\013FeatureDa"
  "ta\022\'\n\007version\030\001 \001(\0132\026.osi3.InterfaceVers"
  "ion\022.\n\014radar_sensor\030\002 \003(\0132\030.osi3.RadarDe"
  "tectionData\022.\n\014lidar_sensor\030\003 \003(\0132\030.osi3"
  ".LidarDetectionData\0228\n\021ultrasonic_sensor"
  "\030\004 \003(\0132\035.osi3.UltrasonicDetectionData\0220\n"
  "\rcamera_sensor\030\005 \003(\0132\031.osi3.CameraDetect"
  "ionData\"\352\t\n\025SensorDetectionHeader\022)\n\020mea"
  "surement_time\030\001 \001(\0132\017.osi3.Timestamp\022\025\n\r"
  "cycle_counter\030\002 \001(\004\0221\n\021mounting_position"
  "\030\003 \001(\0132\026.osi3.MountingPosition\0226\n\026mounti"
  "ng_position_rmse\030\004 \001(\0132\026.osi3.MountingPo"
  "sition\022A\n\016data_qualifier\030\005 \001(\0162).osi3.Se"
  "nsorDetectionHeader.DataQualifier\022\"\n\032num"
  "ber_of_valid_detections\030\006 \001(\r\022#\n\tsensor_"
  "id\030\007 \001(\0132\020.osi3.Identifier\022I\n\022extended_q"
  "ualifier\030\010 \001(\0162-.osi3.SensorDetectionHea"
  "der.ExtendedQualifier\"\215\002\n\rDataQualifier\022"
  "\032\n\026DATA_QUALIFIER_UNKNOWN\020\000\022\030\n\024DATA_QUAL"
  "IFIER_OTHER\020\001\022\034\n\030DATA_QUALIFIER_AVAILABL"
  "E\020\002\022$\n DATA_QUALIFIER_AVAILABLE_REDUCED\020"
  "\003\022 \n\034DATA_QUALIFIER_NOT_AVAILABLE\020\004\022\034\n\030D"
  "ATA_QUALIFIER_BLINDNESS\020\005\022&\n\"DATA_QUALIF"
  "IER_TEMPORARY_AVAILABLE\020\006\022\032\n\026DATA_QUALIF"
  "IER_INVALID\020\007\"\274\004\n\021ExtendedQualifier\022\036\n\032E"
  "XTENDED_QUALIFIER_UNKNOWN\020\000\022\034\n\030EXTENDED_"
  "QUALIFIER_OTHER\020\001\022,\n(EXTENDED_QUALIFIER_"
  "NORMAL_OPERATION_MODE\020\002\022\'\n#EXTENDED_QUAL"
  "IFIER_POWER_UP_OR_DOWN\020\003\022,\n(EXTENDED_QUA"
  "LIFIER_SENSOR_NOT_CALIBRATED\020\004\022%\n!EXTEND"
  "ED_QUALIFIER_SENSOR_BLOCKED\020\005\022(\n$EXTENDE"
  "D_QUALIFIER_SENSOR_MISALIGNED\020\006\0229\n5EXTEN"
  "DED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_C"
  "ONDITION\020\007\022,\n(EXTENDED_QUALIFIER_REDUCED"
  "_FIELD_OF_VIEW\020\010\022*\n&EXTENDED_QUALIFIER_I"
  "NPUT_NOT_AVAILABLE\020\t\022&\n\"EXTENDED_QUALIFI"
  "ER_INTERNAL_REASON\020\n\022+\n\'EXTENDED_QUALIFI"
  "ER_EXTERNAL_DISTURBANCE\020\013\022)\n%EXTENDED_QU"
  "ALIFIER_BEGINNING_BLOCKAGE\020\014\"j\n\022RadarDet"
  "ectionData\022+\n\006header\030\001 \001(\0132\033.osi3.Sensor"
  "DetectionHeader\022\'\n\tdetection\030\002 \003(\0132\024.osi"
  "3.RadarDetection\"\365\002\n\016RadarDetection\022\035\n\025e"
  "xistence_probability\030\001 \001(\001\022#\n\tobject_id\030"
  "\002 \001(\0132\020.osi3.Identifier\022#\n\010position\030\003 \001("
  "\0132\021.osi3.Spherical3d\022(\n\rposition_rmse\030\004 "
  "\001(\0132\021.osi3.Spherical3d\022\027\n\017radial_velocit"
  "y\030\005 \001(\001\022\034\n\024radial_velocity_rmse\030\006 \001(\001\022\013\n"
  "\003rcs\030\007 \001(\001\022\013\n\003snr\030\010 \001(\001\022 \n\030point_target_"
  "probability\030\t \001(\001\022&\n\014ambiguity_id\030\n \001(\0132"
  "\020.osi3.Identifier\0225\n\016classification\030\013 \001("
  "\0162\035.osi3.DetectionClassification\"j\n\022Lida"
  "rDetectionData\022+\n\006header\030\001 \001(\0132\033.osi3.Se"
  "nsorDetectionHeader\022\'\n\tdetection\030\002 \003(\0132\024"
  ".osi3.LidarDetection\"\342\002\n\016LidarDetection\022"
  "\035\n\025existence_probability\030\001 \001(\001\022#\n\tobject"
  "_id\030\002 \001(\0132\020.osi3.Identifier\022#\n\010position\030"
  "\003 \001(\0132\021.osi3.Spherical3d\022(\n\rposition_rms"
  "e\030\004 \001(\0132\021.osi3.Spherical3d\022\016\n\006height\030\005 \001"
  "(\001\022\023\n\013height_rmse\030\006 \001(\001\022\021\n\tintensity\030\007 \001"
  "(\001\022\036\n\026free_space_probability\030\010 \001(\001\0225\n\016cl"
  "assification\030\t \001(\0162\035.osi3.DetectionClass"
  "ification\022\024\n\014reflectivity\030\n \001(\001\022\030\n\020echo_"
  "pulse_width\030\013 \001(\001\"c\n!UltrasonicDetection"
  "SpecificHeader\022\021\n\tmax_range\030\001 \001(\001\022+\n#num"
  "ber_of_valid_indirect_detections\030\002 \001(\r\"\365"
  "\001\n\027UltrasonicDetectionData\022+\n\006header\030\001 \001"
  "(\0132\033.osi3.SensorDetectionHeader\022@\n\017speci"
  "fic_header\030\003 \001(\0132\'.osi3.UltrasonicDetect"
  "ionSpecificHeader\022,\n\tdetection\030\002 \003(\0132\031.o"
  "si3.UltrasonicDetection\022=\n\022indirect_dete"
  "ction\030\004 \003(\0132!.osi3.UltrasonicIndirectDet"
  "ection\"k\n\023UltrasonicDetection\022\035\n\025existen"
  "ce_probability\030\001 \001(\001\022#\n\tobject_id\030\002 \001(\0132"
  "\020.osi3.Identifier\022\020\n\010distance\030\003 \001(\001\"\344\001\n\033"
  "UltrasonicIndirectDetection\022\035\n\025existence"
  "_probability\030\001 \001(\001\022#\n\tobject_id\030\002 \001(\0132\020."
  "osi3.Identifier\022\030\n\020ellipsoid_radial\030\003 \001("
  "\001\022\027\n\017ellipsoid_axial\030\004 \001(\001\022%\n\013receiver_i"
  "d\030\005 \001(\0132\020.osi3.Identifier\022\'\n\017receiver_or"
  "igin\030\006 \001(\0132\016.osi3.Vector3d\"\?\n\035CameraDete"
  "ctionSpecificHeader\022\036\n\026number_of_valid_p"
  "oints\030\001 \001(\r\"\314\001\n\023CameraDetectionData\022+\n\006h"
  "eader\030\001 \001(\0132\033.osi3.SensorDetectionHeader"
  "\022<\n\017specific_header\030\003 \001(\0132#.osi3.CameraD"
  "etectionSpecificHeader\022(\n\tdetection\030\002 \003("
  "\0132\025.osi3.CameraDetection\022 \n\005point\030\004 \003(\0132"
  "\021.osi3.CameraPoint\"\244\016\n\017CameraDetection\022\035"
  "\n\025existence_probability\030\001 \001(\001\022#\n\tobject_"
  "id\030\002 \001(\0132\020.osi3.Identifier\022(\n\017time_diffe"
  "rence\030\003 \001(\0132\017.osi3.Timestamp\022>\n\020image_sh"
  "ape_type\030\004 \001(\0162$.osi3.CameraDetection.Im"
  "ageShapeType\022\'\n\037shape_classification_bac"
  "kground\030\005 \001(\010\022\'\n\037shape_classification_fo"
  "reground\030\006 \001(\010\022!\n\031shape_classification_f"
  "lat\030\007 \001(\010\022$\n\034shape_classification_uprigh"
  "t\030\010 \001(\010\022#\n\033shape_classification_ground\030\t"
  " \001(\010\022 \n\030shape_classification_sky\030\n \001(\010\022\'"
  "\n\037shape_classification_vegetation\030\013 \001(\010\022"
  "!\n\031shape_classification_road\030\014 \001(\010\022-\n%sh"
  "ape_classification_non_driving_lane\030\r \001("
  "\010\022%\n\035shape_classification_non_road\030\016 \001(\010"
  "\022.\n&shape_classification_stationary_obje"
  "ct\030\017 \001(\010\022*\n\"shape_classification_moving_"
  "object\030\020 \001(\010\022%\n\035shape_classification_lan"
  "dmark\030\021 \001(\010\022)\n!shape_classification_traf"
  "fic_sign\030\022 \001(\010\022*\n\"shape_classification_t"
  "raffic_light\030\023 \001(\010\022)\n!shape_classificati"
  "on_road_marking\030\024 \001(\010\022$\n\034shape_classific"
  "ation_vehicle\030\025 \001(\010\022\'\n\037shape_classificat"
  "ion_pedestrian\030\026 \001(\010\022#\n\033shape_classifica"
  "tion_animal\030\027 \001(\010\022-\n%shape_classificatio"
  "n_pedestrian_front\030\030 \001(\010\022,\n$shape_classi"
  "fication_pedestrian_side\030\031 \001(\010\022,\n$shape_"
  "classification_pedestrian_rear\030\032 \001(\010\022(\n "
  "shape_classification_probability\030\033 \001(\001\022*"
  "\n\005color\030\034 \001(\0162\033.osi3.CameraDetection.Col"
  "or\022\031\n\021color_probability\030\035 \001(\001\022&\n\014ambigui"
  "ty_id\030\036 \001(\0132\020.osi3.Identifier\022\031\n\021first_p"
  "oint_index\030\037 \001(\r\022\030\n\020number_of_points\030  \001"
  "(\r\0221\n\021color_description\030! \001(\0132\026.osi3.Col"
  "orDescription\"\331\001\n\005Color\022\021\n\rCOLOR_UNKNOWN"
  "\020\000\022\017\n\013COLOR_OTHER\020\001\022\017\n\013COLOR_BLACK\020\002\022\016\n\n"
  "COLOR_GREY\020\003\022\017\n\013COLOR_WHITE\020\004\022\020\n\014COLOR_Y"
  "ELLOW\020\005\022\020\n\014COLOR_ORANGE\020\006\022\r\n\tCOLOR_RED\020\007"
  "\022\020\n\014COLOR_VIOLET\020\010\022\016\n\nCOLOR_BLUE\020\t\022\017\n\013CO"
  "LOR_GREEN\020\n\022\024\n\020COLOR_REFLECTIVE\020\013\"\375\001\n\016Im"
  "ageShapeType\022\034\n\030IMAGE_SHAPE_TYPE_UNKNOWN"
  "\020\000\022\032\n\026IMAGE_SHAPE_TYPE_OTHER\020\001\022\032\n\026IMAGE_"
  "SHAPE_TYPE_POINT\020\002\022\030\n\024IMAGE_SHAPE_TYPE_B"
  "OX\020\003\022\034\n\030IMAGE_SHAPE_TYPE_ELLIPSE\020\004\022\034\n\030IM"
  "AGE_SHAPE_TYPE_POLYGON\020\005\022\035\n\031IMAGE_SHAPE_"
  "TYPE_POLYLINE\020\006\022 \n\034IMAGE_SHAPE_TYPE_POIN"
  "T_CLOUD\020\007\"u\n\013CameraPoint\022\035\n\025existence_pr"
  "obability\030\001 \001(\001\022 \n\005point\030\002 \001(\0132\021.osi3.Sp"
  "herical3d\022%\n\npoint_rmse\030\003 \001(\0132\021.osi3.Sph"
  "erical3d*\206\002\n\027DetectionClassification\022$\n "
  "DETECTION_CLASSIFICATION_UNKNOWN\020\000\022\"\n\036DE"
  "TECTION_CLASSIFICATION_OTHER\020\001\022$\n DETECT"
  "ION_CLASSIFICATION_INVALID\020\002\022$\n DETECTIO"
  "N_CLASSIFICATION_CLUTTER\020\003\022)\n%DETECTION_"
  "CLASSIFICATION_OVERDRIVABLE\020\004\022*\n&DETECTI"
  "ON_CLASSIFICATION_UNDERDRIVABLE\020\005B\002H\001"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_osi_5ffeaturedata_2eproto_deps[2] = {
  &::descriptor_table_osi_5fcommon_2eproto,
  &::descriptor_table_osi_5fversion_2eproto,
};
static ::_pbi::once_flag descriptor_table_osi_5ffeaturedata_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_osi_5ffeaturedata_2eproto = {
    false, false, 5717, descriptor_table_protodef_osi_5ffeaturedata_2eproto,
    "osi_featuredata.proto",
    &descriptor_table_osi_5ffeaturedata_2eproto_once, descriptor_table_osi_5ffeaturedata_2eproto_deps, 2, 14,
    schemas, file_default_instances, TableStruct_osi_5ffeaturedata_2eproto::offsets,
    file_level_metadata_osi_5ffeaturedata_2eproto, file_level_enum_descriptors_osi_5ffeaturedata_2eproto,
    file_level_service_descriptors_osi_5ffeaturedata_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_osi_5ffeaturedata_2eproto_getter() {
  return &descriptor_table_osi_5ffeaturedata_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_osi_5ffeaturedata_2eproto(&descriptor_table_osi_5ffeaturedata_2eproto);
namespace osi3 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorDetectionHeader_DataQualifier_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[0];
}
bool SensorDetectionHeader_DataQualifier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_UNKNOWN;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_OTHER;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_AVAILABLE;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_AVAILABLE_REDUCED;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_NOT_AVAILABLE;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_BLINDNESS;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_TEMPORARY_AVAILABLE;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_INVALID;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DataQualifier_MIN;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DataQualifier_MAX;
constexpr int SensorDetectionHeader::DataQualifier_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorDetectionHeader_ExtendedQualifier_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[1];
}
bool SensorDetectionHeader_ExtendedQualifier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_UNKNOWN;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_OTHER;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_POWER_UP_OR_DOWN;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_SENSOR_BLOCKED;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_SENSOR_MISALIGNED;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_INTERNAL_REASON;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::ExtendedQualifier_MIN;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::ExtendedQualifier_MAX;
constexpr int SensorDetectionHeader::ExtendedQualifier_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraDetection_Color_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[2];
}
bool CameraDetection_Color_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CameraDetection_Color CameraDetection::COLOR_UNKNOWN;
constexpr CameraDetection_Color CameraDetection::COLOR_OTHER;
constexpr CameraDetection_Color CameraDetection::COLOR_BLACK;
constexpr CameraDetection_Color CameraDetection::COLOR_GREY;
constexpr CameraDetection_Color CameraDetection::COLOR_WHITE;
constexpr CameraDetection_Color CameraDetection::COLOR_YELLOW;
constexpr CameraDetection_Color CameraDetection::COLOR_ORANGE;
constexpr CameraDetection_Color CameraDetection::COLOR_RED;
constexpr CameraDetection_Color CameraDetection::COLOR_VIOLET;
constexpr CameraDetection_Color CameraDetection::COLOR_BLUE;
constexpr CameraDetection_Color CameraDetection::COLOR_GREEN;
constexpr CameraDetection_Color CameraDetection::COLOR_REFLECTIVE;
constexpr CameraDetection_Color CameraDetection::Color_MIN;
constexpr CameraDetection_Color CameraDetection::Color_MAX;
constexpr int CameraDetection::Color_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraDetection_ImageShapeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[3];
}
bool CameraDetection_ImageShapeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_UNKNOWN;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_OTHER;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POINT;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_BOX;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_ELLIPSE;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POLYGON;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POLYLINE;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POINT_CLOUD;
constexpr CameraDetection_ImageShapeType CameraDetection::ImageShapeType_MIN;
constexpr CameraDetection_ImageShapeType CameraDetection::ImageShapeType_MAX;
constexpr int CameraDetection::ImageShapeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DetectionClassification_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[4];
}
bool DetectionClassification_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class FeatureData::_Internal {
 public:
  using HasBits = decltype(std::declval<FeatureData>()._impl_._has_bits_);
  static const ::osi3::InterfaceVersion& version(const FeatureData* msg);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::osi3::InterfaceVersion&
FeatureData::_Internal::version(const FeatureData* msg) {
  return *msg->_impl_.version_;
}
void FeatureData::clear_version() {
  if (_impl_.version_ != nullptr) _impl_.version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FeatureData::FeatureData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.FeatureData)
}
FeatureData::FeatureData(const FeatureData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeatureData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.radar_sensor_){from._impl_.radar_sensor_}
    , decltype(_impl_.lidar_sensor_){from._impl_.lidar_sensor_}
    , decltype(_impl_.ultrasonic_sensor_){from._impl_.ultrasonic_sensor_}
    , decltype(_impl_.camera_sensor_){from._impl_.camera_sensor_}
    , decltype(_impl_.version_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_version()) {
    _this->_impl_.version_ = new ::osi3::InterfaceVersion(*from._impl_.version_);
  }
  // @@protoc_insertion_point(copy_constructor:osi3.FeatureData)
}

inline void FeatureData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.radar_sensor_){arena}
    , decltype(_impl_.lidar_sensor_){arena}
    , decltype(_impl_.ultrasonic_sensor_){arena}
    , decltype(_impl_.camera_sensor_){arena}
    , decltype(_impl_.version_){nullptr}
  };
}

FeatureData::~FeatureData() {
  // @@protoc_insertion_point(destructor:osi3.FeatureData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeatureData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.radar_sensor_.~RepeatedPtrField();
  _impl_.lidar_sensor_.~RepeatedPtrField();
  _impl_.ultrasonic_sensor_.~RepeatedPtrField();
  _impl_.camera_sensor_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.version_;
}

void FeatureData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeatureData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.FeatureData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.radar_sensor_.Clear();
  _impl_.lidar_sensor_.Clear();
  _impl_.ultrasonic_sensor_.Clear();
  _impl_.camera_sensor_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.version_ != nullptr);
    _impl_.version_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeatureData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.InterfaceVersion version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.RadarDetectionData radar_sensor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_radar_sensor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.LidarDetectionData lidar_sensor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_lidar_sensor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ultrasonic_sensor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.CameraDetectionData camera_sensor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_camera_sensor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeatureData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.FeatureData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.InterfaceVersion version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::version(this),
        _Internal::version(this).GetCachedSize(), target, stream);
  }

  // repeated .osi3.RadarDetectionData radar_sensor = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_radar_sensor_size()); i < n; i++) {
    const auto& repfield = this->_internal_radar_sensor(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .osi3.LidarDetectionData lidar_sensor = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lidar_sensor_size()); i < n; i++) {
    const auto& repfield = this->_internal_lidar_sensor(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ultrasonic_sensor_size()); i < n; i++) {
    const auto& repfield = this->_internal_ultrasonic_sensor(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .osi3.CameraDetectionData camera_sensor = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_camera_sensor_size()); i < n; i++) {
    const auto& repfield = this->_internal_camera_sensor(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.FeatureData)
  return target;
}

size_t FeatureData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.FeatureData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.RadarDetectionData radar_sensor = 2;
  total_size += 1UL * this->_internal_radar_sensor_size();
  for (const auto& msg : this->_impl_.radar_sensor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .osi3.LidarDetectionData lidar_sensor = 3;
  total_size += 1UL * this->_internal_lidar_sensor_size();
  for (const auto& msg : this->_impl_.lidar_sensor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
  total_size += 1UL * this->_internal_ultrasonic_sensor_size();
  for (const auto& msg : this->_impl_.ultrasonic_sensor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .osi3.CameraDetectionData camera_sensor = 5;
  total_size += 1UL * this->_internal_camera_sensor_size();
  for (const auto& msg : this->_impl_.camera_sensor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .osi3.InterfaceVersion version = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.version_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeatureData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeatureData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeatureData::GetClassData() const { return &_class_data_; }


void FeatureData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeatureData*>(&to_msg);
  auto& from = static_cast<const FeatureData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.FeatureData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.radar_sensor_.MergeFrom(from._impl_.radar_sensor_);
  _this->_impl_.lidar_sensor_.MergeFrom(from._impl_.lidar_sensor_);
  _this->_impl_.ultrasonic_sensor_.MergeFrom(from._impl_.ultrasonic_sensor_);
  _this->_impl_.camera_sensor_.MergeFrom(from._impl_.camera_sensor_);
  if (from._internal_has_version()) {
    _this->_internal_mutable_version()->::osi3::InterfaceVersion::MergeFrom(
        from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeatureData::CopyFrom(const FeatureData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.FeatureData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureData::IsInitialized() const {
  return true;
}

void FeatureData::InternalSwap(FeatureData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.radar_sensor_.InternalSwap(&other->_impl_.radar_sensor_);
  _impl_.lidar_sensor_.InternalSwap(&other->_impl_.lidar_sensor_);
  _impl_.ultrasonic_sensor_.InternalSwap(&other->_impl_.ultrasonic_sensor_);
  _impl_.camera_sensor_.InternalSwap(&other->_impl_.camera_sensor_);
  swap(_impl_.version_, other->_impl_.version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeatureData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[0]);
}

// ===================================================================

class SensorDetectionHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<SensorDetectionHeader>()._impl_._has_bits_);
  static const ::osi3::Timestamp& measurement_time(const SensorDetectionHeader* msg);
  static void set_has_measurement_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cycle_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::osi3::MountingPosition& mounting_position(const SensorDetectionHeader* msg);
  static void set_has_mounting_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::MountingPosition& mounting_position_rmse(const SensorDetectionHeader* msg);
  static void set_has_mounting_position_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data_qualifier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_valid_detections(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::osi3::Identifier& sensor_id(const SensorDetectionHeader* msg);
  static void set_has_sensor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_extended_qualifier(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::osi3::Timestamp&
SensorDetectionHeader::_Internal::measurement_time(const SensorDetectionHeader* msg) {
  return *msg->_impl_.measurement_time_;
}
const ::osi3::MountingPosition&
SensorDetectionHeader::_Internal::mounting_position(const SensorDetectionHeader* msg) {
  return *msg->_impl_.mounting_position_;
}
const ::osi3::MountingPosition&
SensorDetectionHeader::_Internal::mounting_position_rmse(const SensorDetectionHeader* msg) {
  return *msg->_impl_.mounting_position_rmse_;
}
const ::osi3::Identifier&
SensorDetectionHeader::_Internal::sensor_id(const SensorDetectionHeader* msg) {
  return *msg->_impl_.sensor_id_;
}
void SensorDetectionHeader::clear_measurement_time() {
  if (_impl_.measurement_time_ != nullptr) _impl_.measurement_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void SensorDetectionHeader::clear_mounting_position() {
  if (_impl_.mounting_position_ != nullptr) _impl_.mounting_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void SensorDetectionHeader::clear_mounting_position_rmse() {
  if (_impl_.mounting_position_rmse_ != nullptr) _impl_.mounting_position_rmse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void SensorDetectionHeader::clear_sensor_id() {
  if (_impl_.sensor_id_ != nullptr) _impl_.sensor_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
SensorDetectionHeader::SensorDetectionHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.SensorDetectionHeader)
}
SensorDetectionHeader::SensorDetectionHeader(const SensorDetectionHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SensorDetectionHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.measurement_time_){nullptr}
    , decltype(_impl_.mounting_position_){nullptr}
    , decltype(_impl_.mounting_position_rmse_){nullptr}
    , decltype(_impl_.sensor_id_){nullptr}
    , decltype(_impl_.cycle_counter_){}
    , decltype(_impl_.data_qualifier_){}
    , decltype(_impl_.number_of_valid_detections_){}
    , decltype(_impl_.extended_qualifier_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_measurement_time()) {
    _this->_impl_.measurement_time_ = new ::osi3::Timestamp(*from._impl_.measurement_time_);
  }
  if (from._internal_has_mounting_position()) {
    _this->_impl_.mounting_position_ = new ::osi3::MountingPosition(*from._impl_.mounting_position_);
  }
  if (from._internal_has_mounting_position_rmse()) {
    _this->_impl_.mounting_position_rmse_ = new ::osi3::MountingPosition(*from._impl_.mounting_position_rmse_);
  }
  if (from._internal_has_sensor_id()) {
    _this->_impl_.sensor_id_ = new ::osi3::Identifier(*from._impl_.sensor_id_);
  }
  ::memcpy(&_impl_.cycle_counter_, &from._impl_.cycle_counter_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.extended_qualifier_) -
    reinterpret_cast<char*>(&_impl_.cycle_counter_)) + sizeof(_impl_.extended_qualifier_));
  // @@protoc_insertion_point(copy_constructor:osi3.SensorDetectionHeader)
}

inline void SensorDetectionHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.measurement_time_){nullptr}
    , decltype(_impl_.mounting_position_){nullptr}
    , decltype(_impl_.mounting_position_rmse_){nullptr}
    , decltype(_impl_.sensor_id_){nullptr}
    , decltype(_impl_.cycle_counter_){uint64_t{0u}}
    , decltype(_impl_.data_qualifier_){0}
    , decltype(_impl_.number_of_valid_detections_){0u}
    , decltype(_impl_.extended_qualifier_){0}
  };
}

SensorDetectionHeader::~SensorDetectionHeader() {
  // @@protoc_insertion_point(destructor:osi3.SensorDetectionHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SensorDetectionHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.measurement_time_;
  if (this != internal_default_instance()) delete _impl_.mounting_position_;
  if (this != internal_default_instance()) delete _impl_.mounting_position_rmse_;
  if (this != internal_default_instance()) delete _impl_.sensor_id_;
}

void SensorDetectionHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SensorDetectionHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.SensorDetectionHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.measurement_time_ != nullptr);
      _impl_.measurement_time_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.mounting_position_ != nullptr);
      _impl_.mounting_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.mounting_position_rmse_ != nullptr);
      _impl_.mounting_position_rmse_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.sensor_id_ != nullptr);
      _impl_.sensor_id_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.cycle_counter_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.extended_qualifier_) -
        reinterpret_cast<char*>(&_impl_.cycle_counter_)) + sizeof(_impl_.extended_qualifier_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorDetectionHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.Timestamp measurement_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_measurement_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cycle_counter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cycle_counter(&has_bits);
          _impl_.cycle_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.MountingPosition mounting_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_mounting_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.MountingPosition mounting_position_rmse = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_mounting_position_rmse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::SensorDetectionHeader_DataQualifier_IsValid(val))) {
            _internal_set_data_qualifier(static_cast<::osi3::SensorDetectionHeader_DataQualifier>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_valid_detections = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_number_of_valid_detections(&has_bits);
          _impl_.number_of_valid_detections_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier sensor_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_sensor_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::SensorDetectionHeader_ExtendedQualifier_IsValid(val))) {
            _internal_set_extended_qualifier(static_cast<::osi3::SensorDetectionHeader_ExtendedQualifier>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SensorDetectionHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.SensorDetectionHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.Timestamp measurement_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::measurement_time(this),
        _Internal::measurement_time(this).GetCachedSize(), target, stream);
  }

  // optional uint64 cycle_counter = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_cycle_counter(), target);
  }

  // optional .osi3.MountingPosition mounting_position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::mounting_position(this),
        _Internal::mounting_position(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.MountingPosition mounting_position_rmse = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::mounting_position_rmse(this),
        _Internal::mounting_position_rmse(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_data_qualifier(), target);
  }

  // optional uint32 number_of_valid_detections = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_number_of_valid_detections(), target);
  }

  // optional .osi3.Identifier sensor_id = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::sensor_id(this),
        _Internal::sensor_id(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_extended_qualifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.SensorDetectionHeader)
  return target;
}

size_t SensorDetectionHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.SensorDetectionHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .osi3.Timestamp measurement_time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.measurement_time_);
    }

    // optional .osi3.MountingPosition mounting_position = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mounting_position_);
    }

    // optional .osi3.MountingPosition mounting_position_rmse = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mounting_position_rmse_);
    }

    // optional .osi3.Identifier sensor_id = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sensor_id_);
    }

    // optional uint64 cycle_counter = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cycle_counter());
    }

    // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_data_qualifier());
    }

    // optional uint32 number_of_valid_detections = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_valid_detections());
    }

    // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_extended_qualifier());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SensorDetectionHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SensorDetectionHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SensorDetectionHeader::GetClassData() const { return &_class_data_; }


void SensorDetectionHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SensorDetectionHeader*>(&to_msg);
  auto& from = static_cast<const SensorDetectionHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.SensorDetectionHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_measurement_time()->::osi3::Timestamp::MergeFrom(
          from._internal_measurement_time());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_mounting_position()->::osi3::MountingPosition::MergeFrom(
          from._internal_mounting_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_mounting_position_rmse()->::osi3::MountingPosition::MergeFrom(
          from._internal_mounting_position_rmse());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_sensor_id()->::osi3::Identifier::MergeFrom(
          from._internal_sensor_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.cycle_counter_ = from._impl_.cycle_counter_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.data_qualifier_ = from._impl_.data_qualifier_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.number_of_valid_detections_ = from._impl_.number_of_valid_detections_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.extended_qualifier_ = from._impl_.extended_qualifier_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SensorDetectionHeader::CopyFrom(const SensorDetectionHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.SensorDetectionHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorDetectionHeader::IsInitialized() const {
  return true;
}

void SensorDetectionHeader::InternalSwap(SensorDetectionHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.extended_qualifier_)
      + sizeof(SensorDetectionHeader::_impl_.extended_qualifier_)
      - PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.measurement_time_)>(
          reinterpret_cast<char*>(&_impl_.measurement_time_),
          reinterpret_cast<char*>(&other->_impl_.measurement_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorDetectionHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[1]);
}

// ===================================================================

class RadarDetectionData::_Internal {
 public:
  using HasBits = decltype(std::declval<RadarDetectionData>()._impl_._has_bits_);
  static const ::osi3::SensorDetectionHeader& header(const RadarDetectionData* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::osi3::SensorDetectionHeader&
RadarDetectionData::_Internal::header(const RadarDetectionData* msg) {
  return *msg->_impl_.header_;
}
RadarDetectionData::RadarDetectionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.RadarDetectionData)
}
RadarDetectionData::RadarDetectionData(const RadarDetectionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RadarDetectionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.detection_){from._impl_.detection_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::osi3::SensorDetectionHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:osi3.RadarDetectionData)
}

inline void RadarDetectionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.detection_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

RadarDetectionData::~RadarDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.RadarDetectionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RadarDetectionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.detection_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void RadarDetectionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RadarDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.RadarDetectionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detection_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RadarDetectionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.SensorDetectionHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.RadarDetection detection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_detection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RadarDetectionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.RadarDetectionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.SensorDetectionHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .osi3.RadarDetection detection = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_detection_size()); i < n; i++) {
    const auto& repfield = this->_internal_detection(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.RadarDetectionData)
  return target;
}

size_t RadarDetectionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.RadarDetectionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.RadarDetection detection = 2;
  total_size += 1UL * this->_internal_detection_size();
  for (const auto& msg : this->_impl_.detection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .osi3.SensorDetectionHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RadarDetectionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RadarDetectionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RadarDetectionData::GetClassData() const { return &_class_data_; }


void RadarDetectionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RadarDetectionData*>(&to_msg);
  auto& from = static_cast<const RadarDetectionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.RadarDetectionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.detection_.MergeFrom(from._impl_.detection_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::osi3::SensorDetectionHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RadarDetectionData::CopyFrom(const RadarDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.RadarDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadarDetectionData::IsInitialized() const {
  return true;
}

void RadarDetectionData::InternalSwap(RadarDetectionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.detection_.InternalSwap(&other->_impl_.detection_);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RadarDetectionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[2]);
}

// ===================================================================

class RadarDetection::_Internal {
 public:
  using HasBits = decltype(std::declval<RadarDetection>()._impl_._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::osi3::Identifier& object_id(const RadarDetection* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Spherical3d& position(const RadarDetection* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Spherical3d& position_rmse(const RadarDetection* msg);
  static void set_has_position_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_radial_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radial_velocity_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_rcs(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_snr(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_point_target_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::osi3::Identifier& ambiguity_id(const RadarDetection* msg);
  static void set_has_ambiguity_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_classification(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::osi3::Identifier&
RadarDetection::_Internal::object_id(const RadarDetection* msg) {
  return *msg->_impl_.object_id_;
}
const ::osi3::Spherical3d&
RadarDetection::_Internal::position(const RadarDetection* msg) {
  return *msg->_impl_.position_;
}
const ::osi3::Spherical3d&
RadarDetection::_Internal::position_rmse(const RadarDetection* msg) {
  return *msg->_impl_.position_rmse_;
}
const ::osi3::Identifier&
RadarDetection::_Internal::ambiguity_id(const RadarDetection* msg) {
  return *msg->_impl_.ambiguity_id_;
}
void RadarDetection::clear_object_id() {
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RadarDetection::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RadarDetection::clear_position_rmse() {
  if (_impl_.position_rmse_ != nullptr) _impl_.position_rmse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void RadarDetection::clear_ambiguity_id() {
  if (_impl_.ambiguity_id_ != nullptr) _impl_.ambiguity_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
RadarDetection::RadarDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.RadarDetection)
}
RadarDetection::RadarDetection(const RadarDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RadarDetection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_id_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.position_rmse_){nullptr}
    , decltype(_impl_.ambiguity_id_){nullptr}
    , decltype(_impl_.existence_probability_){}
    , decltype(_impl_.radial_velocity_){}
    , decltype(_impl_.radial_velocity_rmse_){}
    , decltype(_impl_.rcs_){}
    , decltype(_impl_.snr_){}
    , decltype(_impl_.point_target_probability_){}
    , decltype(_impl_.classification_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_object_id()) {
    _this->_impl_.object_id_ = new ::osi3::Identifier(*from._impl_.object_id_);
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::osi3::Spherical3d(*from._impl_.position_);
  }
  if (from._internal_has_position_rmse()) {
    _this->_impl_.position_rmse_ = new ::osi3::Spherical3d(*from._impl_.position_rmse_);
  }
  if (from._internal_has_ambiguity_id()) {
    _this->_impl_.ambiguity_id_ = new ::osi3::Identifier(*from._impl_.ambiguity_id_);
  }
  ::memcpy(&_impl_.existence_probability_, &from._impl_.existence_probability_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.classification_) -
    reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.classification_));
  // @@protoc_insertion_point(copy_constructor:osi3.RadarDetection)
}

inline void RadarDetection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_id_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.position_rmse_){nullptr}
    , decltype(_impl_.ambiguity_id_){nullptr}
    , decltype(_impl_.existence_probability_){0}
    , decltype(_impl_.radial_velocity_){0}
    , decltype(_impl_.radial_velocity_rmse_){0}
    , decltype(_impl_.rcs_){0}
    , decltype(_impl_.snr_){0}
    , decltype(_impl_.point_target_probability_){0}
    , decltype(_impl_.classification_){0}
  };
}

RadarDetection::~RadarDetection() {
  // @@protoc_insertion_point(destructor:osi3.RadarDetection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RadarDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.object_id_;
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.position_rmse_;
  if (this != internal_default_instance()) delete _impl_.ambiguity_id_;
}

void RadarDetection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RadarDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.RadarDetection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.object_id_ != nullptr);
      _impl_.object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.position_rmse_ != nullptr);
      _impl_.position_rmse_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.ambiguity_id_ != nullptr);
      _impl_.ambiguity_id_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.existence_probability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rcs_) -
        reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.rcs_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.snr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.classification_) -
        reinterpret_cast<char*>(&_impl_.snr_)) + sizeof(_impl_.classification_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RadarDetection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_existence_probability(&has_bits);
          _impl_.existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier object_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d position_rmse = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_position_rmse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double radial_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_radial_velocity(&has_bits);
          _impl_.radial_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double radial_velocity_rmse = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_radial_velocity_rmse(&has_bits);
          _impl_.radial_velocity_rmse_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double rcs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_rcs(&has_bits);
          _impl_.rcs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double snr = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_snr(&has_bits);
          _impl_.snr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double point_target_probability = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_point_target_probability(&has_bits);
          _impl_.point_target_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier ambiguity_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_ambiguity_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.DetectionClassification classification = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::DetectionClassification_IsValid(val))) {
            _internal_set_classification(static_cast<::osi3::DetectionClassification>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RadarDetection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.RadarDetection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::object_id(this),
        _Internal::object_id(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Spherical3d position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Spherical3d position_rmse = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::position_rmse(this),
        _Internal::position_rmse(this).GetCachedSize(), target, stream);
  }

  // optional double radial_velocity = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_radial_velocity(), target);
  }

  // optional double radial_velocity_rmse = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_radial_velocity_rmse(), target);
  }

  // optional double rcs = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_rcs(), target);
  }

  // optional double snr = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_snr(), target);
  }

  // optional double point_target_probability = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_point_target_probability(), target);
  }

  // optional .osi3.Identifier ambiguity_id = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::ambiguity_id(this),
        _Internal::ambiguity_id(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.DetectionClassification classification = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      11, this->_internal_classification(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.RadarDetection)
  return target;
}

size_t RadarDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.RadarDetection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .osi3.Identifier object_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_id_);
    }

    // optional .osi3.Spherical3d position = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .osi3.Spherical3d position_rmse = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_rmse_);
    }

    // optional .osi3.Identifier ambiguity_id = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ambiguity_id_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double radial_velocity = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double radial_velocity_rmse = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double rcs = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional double snr = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double point_target_probability = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional .osi3.DetectionClassification classification = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_classification());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RadarDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RadarDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RadarDetection::GetClassData() const { return &_class_data_; }


void RadarDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RadarDetection*>(&to_msg);
  auto& from = static_cast<const RadarDetection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.RadarDetection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_object_id()->::osi3::Identifier::MergeFrom(
          from._internal_object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_position()->::osi3::Spherical3d::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_position_rmse()->::osi3::Spherical3d::MergeFrom(
          from._internal_position_rmse());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_ambiguity_id()->::osi3::Identifier::MergeFrom(
          from._internal_ambiguity_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.radial_velocity_ = from._impl_.radial_velocity_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.radial_velocity_rmse_ = from._impl_.radial_velocity_rmse_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.rcs_ = from._impl_.rcs_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.snr_ = from._impl_.snr_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.point_target_probability_ = from._impl_.point_target_probability_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.classification_ = from._impl_.classification_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RadarDetection::CopyFrom(const RadarDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.RadarDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadarDetection::IsInitialized() const {
  return true;
}

void RadarDetection::InternalSwap(RadarDetection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.classification_)
      + sizeof(RadarDetection::_impl_.classification_)
      - PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.object_id_)>(
          reinterpret_cast<char*>(&_impl_.object_id_),
          reinterpret_cast<char*>(&other->_impl_.object_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RadarDetection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[3]);
}

// ===================================================================

class LidarDetectionData::_Internal {
 public:
  using HasBits = decltype(std::declval<LidarDetectionData>()._impl_._has_bits_);
  static const ::osi3::SensorDetectionHeader& header(const LidarDetectionData* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::osi3::SensorDetectionHeader&
LidarDetectionData::_Internal::header(const LidarDetectionData* msg) {
  return *msg->_impl_.header_;
}
LidarDetectionData::LidarDetectionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.LidarDetectionData)
}
LidarDetectionData::LidarDetectionData(const LidarDetectionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LidarDetectionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.detection_){from._impl_.detection_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::osi3::SensorDetectionHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:osi3.LidarDetectionData)
}

inline void LidarDetectionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.detection_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

LidarDetectionData::~LidarDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.LidarDetectionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LidarDetectionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.detection_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LidarDetectionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LidarDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LidarDetectionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detection_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LidarDetectionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.SensorDetectionHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.LidarDetection detection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_detection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LidarDetectionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.LidarDetectionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.SensorDetectionHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .osi3.LidarDetection detection = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_detection_size()); i < n; i++) {
    const auto& repfield = this->_internal_detection(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.LidarDetectionData)
  return target;
}

size_t LidarDetectionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.LidarDetectionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.LidarDetection detection = 2;
  total_size += 1UL * this->_internal_detection_size();
  for (const auto& msg : this->_impl_.detection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .osi3.SensorDetectionHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LidarDetectionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LidarDetectionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LidarDetectionData::GetClassData() const { return &_class_data_; }


void LidarDetectionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LidarDetectionData*>(&to_msg);
  auto& from = static_cast<const LidarDetectionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LidarDetectionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.detection_.MergeFrom(from._impl_.detection_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::osi3::SensorDetectionHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LidarDetectionData::CopyFrom(const LidarDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LidarDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LidarDetectionData::IsInitialized() const {
  return true;
}

void LidarDetectionData::InternalSwap(LidarDetectionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.detection_.InternalSwap(&other->_impl_.detection_);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LidarDetectionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[4]);
}

// ===================================================================

class LidarDetection::_Internal {
 public:
  using HasBits = decltype(std::declval<LidarDetection>()._impl_._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::osi3::Identifier& object_id(const LidarDetection* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Spherical3d& position(const LidarDetection* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Spherical3d& position_rmse(const LidarDetection* msg);
  static void set_has_position_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_height_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_intensity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_free_space_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_classification(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_reflectivity(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_echo_pulse_width(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::osi3::Identifier&
LidarDetection::_Internal::object_id(const LidarDetection* msg) {
  return *msg->_impl_.object_id_;
}
const ::osi3::Spherical3d&
LidarDetection::_Internal::position(const LidarDetection* msg) {
  return *msg->_impl_.position_;
}
const ::osi3::Spherical3d&
LidarDetection::_Internal::position_rmse(const LidarDetection* msg) {
  return *msg->_impl_.position_rmse_;
}
void LidarDetection::clear_object_id() {
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void LidarDetection::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void LidarDetection::clear_position_rmse() {
  if (_impl_.position_rmse_ != nullptr) _impl_.position_rmse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
LidarDetection::LidarDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.LidarDetection)
}
LidarDetection::LidarDetection(const LidarDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LidarDetection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_id_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.position_rmse_){nullptr}
    , decltype(_impl_.existence_probability_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.height_rmse_){}
    , decltype(_impl_.intensity_){}
    , decltype(_impl_.free_space_probability_){}
    , decltype(_impl_.reflectivity_){}
    , decltype(_impl_.echo_pulse_width_){}
    , decltype(_impl_.classification_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_object_id()) {
    _this->_impl_.object_id_ = new ::osi3::Identifier(*from._impl_.object_id_);
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::osi3::Spherical3d(*from._impl_.position_);
  }
  if (from._internal_has_position_rmse()) {
    _this->_impl_.position_rmse_ = new ::osi3::Spherical3d(*from._impl_.position_rmse_);
  }
  ::memcpy(&_impl_.existence_probability_, &from._impl_.existence_probability_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.classification_) -
    reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.classification_));
  // @@protoc_insertion_point(copy_constructor:osi3.LidarDetection)
}

inline void LidarDetection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_id_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.position_rmse_){nullptr}
    , decltype(_impl_.existence_probability_){0}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.height_rmse_){0}
    , decltype(_impl_.intensity_){0}
    , decltype(_impl_.free_space_probability_){0}
    , decltype(_impl_.reflectivity_){0}
    , decltype(_impl_.echo_pulse_width_){0}
    , decltype(_impl_.classification_){0}
  };
}

LidarDetection::~LidarDetection() {
  // @@protoc_insertion_point(destructor:osi3.LidarDetection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LidarDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.object_id_;
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.position_rmse_;
}

void LidarDetection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LidarDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LidarDetection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.object_id_ != nullptr);
      _impl_.object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.position_rmse_ != nullptr);
      _impl_.position_rmse_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.existence_probability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.free_space_probability_) -
        reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.free_space_probability_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.reflectivity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.classification_) -
        reinterpret_cast<char*>(&_impl_.reflectivity_)) + sizeof(_impl_.classification_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LidarDetection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_existence_probability(&has_bits);
          _impl_.existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier object_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d position_rmse = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_position_rmse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double height = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double height_rmse = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_height_rmse(&has_bits);
          _impl_.height_rmse_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double intensity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_intensity(&has_bits);
          _impl_.intensity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double free_space_probability = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_free_space_probability(&has_bits);
          _impl_.free_space_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.DetectionClassification classification = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::DetectionClassification_IsValid(val))) {
            _internal_set_classification(static_cast<::osi3::DetectionClassification>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double reflectivity = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_reflectivity(&has_bits);
          _impl_.reflectivity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double echo_pulse_width = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_echo_pulse_width(&has_bits);
          _impl_.echo_pulse_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LidarDetection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.LidarDetection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::object_id(this),
        _Internal::object_id(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Spherical3d position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Spherical3d position_rmse = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::position_rmse(this),
        _Internal::position_rmse(this).GetCachedSize(), target, stream);
  }

  // optional double height = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_height(), target);
  }

  // optional double height_rmse = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_height_rmse(), target);
  }

  // optional double intensity = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_intensity(), target);
  }

  // optional double free_space_probability = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_free_space_probability(), target);
  }

  // optional .osi3.DetectionClassification classification = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_classification(), target);
  }

  // optional double reflectivity = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_reflectivity(), target);
  }

  // optional double echo_pulse_width = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_echo_pulse_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.LidarDetection)
  return target;
}

size_t LidarDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.LidarDetection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .osi3.Identifier object_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_id_);
    }

    // optional .osi3.Spherical3d position = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .osi3.Spherical3d position_rmse = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_rmse_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double height = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double height_rmse = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double intensity = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double free_space_probability = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional double reflectivity = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double echo_pulse_width = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional .osi3.DetectionClassification classification = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_classification());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LidarDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LidarDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LidarDetection::GetClassData() const { return &_class_data_; }


void LidarDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LidarDetection*>(&to_msg);
  auto& from = static_cast<const LidarDetection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LidarDetection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_object_id()->::osi3::Identifier::MergeFrom(
          from._internal_object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_position()->::osi3::Spherical3d::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_position_rmse()->::osi3::Spherical3d::MergeFrom(
          from._internal_position_rmse());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.height_rmse_ = from._impl_.height_rmse_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.intensity_ = from._impl_.intensity_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.free_space_probability_ = from._impl_.free_space_probability_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.reflectivity_ = from._impl_.reflectivity_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.echo_pulse_width_ = from._impl_.echo_pulse_width_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.classification_ = from._impl_.classification_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LidarDetection::CopyFrom(const LidarDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LidarDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LidarDetection::IsInitialized() const {
  return true;
}

void LidarDetection::InternalSwap(LidarDetection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.classification_)
      + sizeof(LidarDetection::_impl_.classification_)
      - PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.object_id_)>(
          reinterpret_cast<char*>(&_impl_.object_id_),
          reinterpret_cast<char*>(&other->_impl_.object_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LidarDetection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[5]);
}

// ===================================================================

class UltrasonicDetectionSpecificHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<UltrasonicDetectionSpecificHeader>()._impl_._has_bits_);
  static void set_has_max_range(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_number_of_valid_indirect_detections(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UltrasonicDetectionSpecificHeader::UltrasonicDetectionSpecificHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicDetectionSpecificHeader)
}
UltrasonicDetectionSpecificHeader::UltrasonicDetectionSpecificHeader(const UltrasonicDetectionSpecificHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UltrasonicDetectionSpecificHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.max_range_){}
    , decltype(_impl_.number_of_valid_indirect_detections_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.max_range_, &from._impl_.max_range_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.number_of_valid_indirect_detections_) -
    reinterpret_cast<char*>(&_impl_.max_range_)) + sizeof(_impl_.number_of_valid_indirect_detections_));
  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicDetectionSpecificHeader)
}

inline void UltrasonicDetectionSpecificHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.max_range_){0}
    , decltype(_impl_.number_of_valid_indirect_detections_){0u}
  };
}

UltrasonicDetectionSpecificHeader::~UltrasonicDetectionSpecificHeader() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicDetectionSpecificHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UltrasonicDetectionSpecificHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UltrasonicDetectionSpecificHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UltrasonicDetectionSpecificHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicDetectionSpecificHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.max_range_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_valid_indirect_detections_) -
        reinterpret_cast<char*>(&_impl_.max_range_)) + sizeof(_impl_.number_of_valid_indirect_detections_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UltrasonicDetectionSpecificHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double max_range = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_max_range(&has_bits);
          _impl_.max_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_valid_indirect_detections = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_number_of_valid_indirect_detections(&has_bits);
          _impl_.number_of_valid_indirect_detections_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UltrasonicDetectionSpecificHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicDetectionSpecificHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double max_range = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_max_range(), target);
  }

  // optional uint32 number_of_valid_indirect_detections = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_number_of_valid_indirect_detections(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicDetectionSpecificHeader)
  return target;
}

size_t UltrasonicDetectionSpecificHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicDetectionSpecificHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double max_range = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 number_of_valid_indirect_detections = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_valid_indirect_detections());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UltrasonicDetectionSpecificHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UltrasonicDetectionSpecificHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UltrasonicDetectionSpecificHeader::GetClassData() const { return &_class_data_; }


void UltrasonicDetectionSpecificHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UltrasonicDetectionSpecificHeader*>(&to_msg);
  auto& from = static_cast<const UltrasonicDetectionSpecificHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicDetectionSpecificHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.max_range_ = from._impl_.max_range_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.number_of_valid_indirect_detections_ = from._impl_.number_of_valid_indirect_detections_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicDetectionSpecificHeader::CopyFrom(const UltrasonicDetectionSpecificHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicDetectionSpecificHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UltrasonicDetectionSpecificHeader::IsInitialized() const {
  return true;
}

void UltrasonicDetectionSpecificHeader::InternalSwap(UltrasonicDetectionSpecificHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_.number_of_valid_indirect_detections_)
      + sizeof(UltrasonicDetectionSpecificHeader::_impl_.number_of_valid_indirect_detections_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_.max_range_)>(
          reinterpret_cast<char*>(&_impl_.max_range_),
          reinterpret_cast<char*>(&other->_impl_.max_range_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UltrasonicDetectionSpecificHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[6]);
}

// ===================================================================

class UltrasonicDetectionData::_Internal {
 public:
  using HasBits = decltype(std::declval<UltrasonicDetectionData>()._impl_._has_bits_);
  static const ::osi3::SensorDetectionHeader& header(const UltrasonicDetectionData* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::UltrasonicDetectionSpecificHeader& specific_header(const UltrasonicDetectionData* msg);
  static void set_has_specific_header(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::osi3::SensorDetectionHeader&
UltrasonicDetectionData::_Internal::header(const UltrasonicDetectionData* msg) {
  return *msg->_impl_.header_;
}
const ::osi3::UltrasonicDetectionSpecificHeader&
UltrasonicDetectionData::_Internal::specific_header(const UltrasonicDetectionData* msg) {
  return *msg->_impl_.specific_header_;
}
UltrasonicDetectionData::UltrasonicDetectionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicDetectionData)
}
UltrasonicDetectionData::UltrasonicDetectionData(const UltrasonicDetectionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UltrasonicDetectionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.detection_){from._impl_.detection_}
    , decltype(_impl_.indirect_detection_){from._impl_.indirect_detection_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.specific_header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::osi3::SensorDetectionHeader(*from._impl_.header_);
  }
  if (from._internal_has_specific_header()) {
    _this->_impl_.specific_header_ = new ::osi3::UltrasonicDetectionSpecificHeader(*from._impl_.specific_header_);
  }
  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicDetectionData)
}

inline void UltrasonicDetectionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.detection_){arena}
    , decltype(_impl_.indirect_detection_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.specific_header_){nullptr}
  };
}

UltrasonicDetectionData::~UltrasonicDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicDetectionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UltrasonicDetectionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.detection_.~RepeatedPtrField();
  _impl_.indirect_detection_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.specific_header_;
}

void UltrasonicDetectionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UltrasonicDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicDetectionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detection_.Clear();
  _impl_.indirect_detection_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.specific_header_ != nullptr);
      _impl_.specific_header_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UltrasonicDetectionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.SensorDetectionHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.UltrasonicDetection detection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_detection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_specific_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_indirect_detection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UltrasonicDetectionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicDetectionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.SensorDetectionHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .osi3.UltrasonicDetection detection = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_detection_size()); i < n; i++) {
    const auto& repfield = this->_internal_detection(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::specific_header(this),
        _Internal::specific_header(this).GetCachedSize(), target, stream);
  }

  // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_indirect_detection_size()); i < n; i++) {
    const auto& repfield = this->_internal_indirect_detection(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicDetectionData)
  return target;
}

size_t UltrasonicDetectionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicDetectionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.UltrasonicDetection detection = 2;
  total_size += 1UL * this->_internal_detection_size();
  for (const auto& msg : this->_impl_.detection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
  total_size += 1UL * this->_internal_indirect_detection_size();
  for (const auto& msg : this->_impl_.indirect_detection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .osi3.SensorDetectionHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.specific_header_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UltrasonicDetectionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UltrasonicDetectionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UltrasonicDetectionData::GetClassData() const { return &_class_data_; }


void UltrasonicDetectionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UltrasonicDetectionData*>(&to_msg);
  auto& from = static_cast<const UltrasonicDetectionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicDetectionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.detection_.MergeFrom(from._impl_.detection_);
  _this->_impl_.indirect_detection_.MergeFrom(from._impl_.indirect_detection_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header()->::osi3::SensorDetectionHeader::MergeFrom(
          from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_specific_header()->::osi3::UltrasonicDetectionSpecificHeader::MergeFrom(
          from._internal_specific_header());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicDetectionData::CopyFrom(const UltrasonicDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UltrasonicDetectionData::IsInitialized() const {
  return true;
}

void UltrasonicDetectionData::InternalSwap(UltrasonicDetectionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.detection_.InternalSwap(&other->_impl_.detection_);
  _impl_.indirect_detection_.InternalSwap(&other->_impl_.indirect_detection_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.specific_header_)
      + sizeof(UltrasonicDetectionData::_impl_.specific_header_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UltrasonicDetectionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[7]);
}

// ===================================================================

class UltrasonicDetection::_Internal {
 public:
  using HasBits = decltype(std::declval<UltrasonicDetection>()._impl_._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Identifier& object_id(const UltrasonicDetection* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::osi3::Identifier&
UltrasonicDetection::_Internal::object_id(const UltrasonicDetection* msg) {
  return *msg->_impl_.object_id_;
}
void UltrasonicDetection::clear_object_id() {
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
UltrasonicDetection::UltrasonicDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicDetection)
}
UltrasonicDetection::UltrasonicDetection(const UltrasonicDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UltrasonicDetection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_id_){nullptr}
    , decltype(_impl_.existence_probability_){}
    , decltype(_impl_.distance_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_object_id()) {
    _this->_impl_.object_id_ = new ::osi3::Identifier(*from._impl_.object_id_);
  }
  ::memcpy(&_impl_.existence_probability_, &from._impl_.existence_probability_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.distance_) -
    reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.distance_));
  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicDetection)
}

inline void UltrasonicDetection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_id_){nullptr}
    , decltype(_impl_.existence_probability_){0}
    , decltype(_impl_.distance_){0}
  };
}

UltrasonicDetection::~UltrasonicDetection() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicDetection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UltrasonicDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.object_id_;
}

void UltrasonicDetection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UltrasonicDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicDetection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.object_id_ != nullptr);
    _impl_.object_id_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.existence_probability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.distance_) -
        reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.distance_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UltrasonicDetection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_existence_probability(&has_bits);
          _impl_.existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier object_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double distance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_distance(&has_bits);
          _impl_.distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UltrasonicDetection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicDetection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::object_id(this),
        _Internal::object_id(this).GetCachedSize(), target, stream);
  }

  // optional double distance = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicDetection)
  return target;
}

size_t UltrasonicDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicDetection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .osi3.Identifier object_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_id_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double distance = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UltrasonicDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UltrasonicDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UltrasonicDetection::GetClassData() const { return &_class_data_; }


void UltrasonicDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UltrasonicDetection*>(&to_msg);
  auto& from = static_cast<const UltrasonicDetection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicDetection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_object_id()->::osi3::Identifier::MergeFrom(
          from._internal_object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.distance_ = from._impl_.distance_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicDetection::CopyFrom(const UltrasonicDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UltrasonicDetection::IsInitialized() const {
  return true;
}

void UltrasonicDetection::InternalSwap(UltrasonicDetection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_.distance_)
      + sizeof(UltrasonicDetection::_impl_.distance_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_.object_id_)>(
          reinterpret_cast<char*>(&_impl_.object_id_),
          reinterpret_cast<char*>(&other->_impl_.object_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UltrasonicDetection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[8]);
}

// ===================================================================

class UltrasonicIndirectDetection::_Internal {
 public:
  using HasBits = decltype(std::declval<UltrasonicIndirectDetection>()._impl_._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::osi3::Identifier& object_id(const UltrasonicIndirectDetection* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ellipsoid_radial(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ellipsoid_axial(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::osi3::Identifier& receiver_id(const UltrasonicIndirectDetection* msg);
  static void set_has_receiver_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Vector3d& receiver_origin(const UltrasonicIndirectDetection* msg);
  static void set_has_receiver_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::osi3::Identifier&
UltrasonicIndirectDetection::_Internal::object_id(const UltrasonicIndirectDetection* msg) {
  return *msg->_impl_.object_id_;
}
const ::osi3::Identifier&
UltrasonicIndirectDetection::_Internal::receiver_id(const UltrasonicIndirectDetection* msg) {
  return *msg->_impl_.receiver_id_;
}
const ::osi3::Vector3d&
UltrasonicIndirectDetection::_Internal::receiver_origin(const UltrasonicIndirectDetection* msg) {
  return *msg->_impl_.receiver_origin_;
}
void UltrasonicIndirectDetection::clear_object_id() {
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void UltrasonicIndirectDetection::clear_receiver_id() {
  if (_impl_.receiver_id_ != nullptr) _impl_.receiver_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void UltrasonicIndirectDetection::clear_receiver_origin() {
  if (_impl_.receiver_origin_ != nullptr) _impl_.receiver_origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
UltrasonicIndirectDetection::UltrasonicIndirectDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicIndirectDetection)
}
UltrasonicIndirectDetection::UltrasonicIndirectDetection(const UltrasonicIndirectDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UltrasonicIndirectDetection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_id_){nullptr}
    , decltype(_impl_.receiver_id_){nullptr}
    , decltype(_impl_.receiver_origin_){nullptr}
    , decltype(_impl_.existence_probability_){}
    , decltype(_impl_.ellipsoid_radial_){}
    , decltype(_impl_.ellipsoid_axial_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_object_id()) {
    _this->_impl_.object_id_ = new ::osi3::Identifier(*from._impl_.object_id_);
  }
  if (from._internal_has_receiver_id()) {
    _this->_impl_.receiver_id_ = new ::osi3::Identifier(*from._impl_.receiver_id_);
  }
  if (from._internal_has_receiver_origin()) {
    _this->_impl_.receiver_origin_ = new ::osi3::Vector3d(*from._impl_.receiver_origin_);
  }
  ::memcpy(&_impl_.existence_probability_, &from._impl_.existence_probability_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ellipsoid_axial_) -
    reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.ellipsoid_axial_));
  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicIndirectDetection)
}

inline void UltrasonicIndirectDetection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_id_){nullptr}
    , decltype(_impl_.receiver_id_){nullptr}
    , decltype(_impl_.receiver_origin_){nullptr}
    , decltype(_impl_.existence_probability_){0}
    , decltype(_impl_.ellipsoid_radial_){0}
    , decltype(_impl_.ellipsoid_axial_){0}
  };
}

UltrasonicIndirectDetection::~UltrasonicIndirectDetection() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicIndirectDetection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UltrasonicIndirectDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.object_id_;
  if (this != internal_default_instance()) delete _impl_.receiver_id_;
  if (this != internal_default_instance()) delete _impl_.receiver_origin_;
}

void UltrasonicIndirectDetection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UltrasonicIndirectDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicIndirectDetection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.object_id_ != nullptr);
      _impl_.object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.receiver_id_ != nullptr);
      _impl_.receiver_id_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.receiver_origin_ != nullptr);
      _impl_.receiver_origin_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.existence_probability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ellipsoid_axial_) -
        reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.ellipsoid_axial_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UltrasonicIndirectDetection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_existence_probability(&has_bits);
          _impl_.existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier object_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double ellipsoid_radial = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_ellipsoid_radial(&has_bits);
          _impl_.ellipsoid_radial_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double ellipsoid_axial = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_ellipsoid_axial(&has_bits);
          _impl_.ellipsoid_axial_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier receiver_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_receiver_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Vector3d receiver_origin = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_receiver_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UltrasonicIndirectDetection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicIndirectDetection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::object_id(this),
        _Internal::object_id(this).GetCachedSize(), target, stream);
  }

  // optional double ellipsoid_radial = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_ellipsoid_radial(), target);
  }

  // optional double ellipsoid_axial = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_ellipsoid_axial(), target);
  }

  // optional .osi3.Identifier receiver_id = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::receiver_id(this),
        _Internal::receiver_id(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Vector3d receiver_origin = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::receiver_origin(this),
        _Internal::receiver_origin(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicIndirectDetection)
  return target;
}

size_t UltrasonicIndirectDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicIndirectDetection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .osi3.Identifier object_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_id_);
    }

    // optional .osi3.Identifier receiver_id = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.receiver_id_);
    }

    // optional .osi3.Vector3d receiver_origin = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.receiver_origin_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double ellipsoid_radial = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double ellipsoid_axial = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UltrasonicIndirectDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UltrasonicIndirectDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UltrasonicIndirectDetection::GetClassData() const { return &_class_data_; }


void UltrasonicIndirectDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UltrasonicIndirectDetection*>(&to_msg);
  auto& from = static_cast<const UltrasonicIndirectDetection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicIndirectDetection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_object_id()->::osi3::Identifier::MergeFrom(
          from._internal_object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_receiver_id()->::osi3::Identifier::MergeFrom(
          from._internal_receiver_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_receiver_origin()->::osi3::Vector3d::MergeFrom(
          from._internal_receiver_origin());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ellipsoid_radial_ = from._impl_.ellipsoid_radial_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ellipsoid_axial_ = from._impl_.ellipsoid_axial_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicIndirectDetection::CopyFrom(const UltrasonicIndirectDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicIndirectDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UltrasonicIndirectDetection::IsInitialized() const {
  return true;
}

void UltrasonicIndirectDetection::InternalSwap(UltrasonicIndirectDetection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.ellipsoid_axial_)
      + sizeof(UltrasonicIndirectDetection::_impl_.ellipsoid_axial_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.object_id_)>(
          reinterpret_cast<char*>(&_impl_.object_id_),
          reinterpret_cast<char*>(&other->_impl_.object_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UltrasonicIndirectDetection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[9]);
}

// ===================================================================

class CameraDetectionSpecificHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<CameraDetectionSpecificHeader>()._impl_._has_bits_);
  static void set_has_number_of_valid_points(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CameraDetectionSpecificHeader::CameraDetectionSpecificHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.CameraDetectionSpecificHeader)
}
CameraDetectionSpecificHeader::CameraDetectionSpecificHeader(const CameraDetectionSpecificHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CameraDetectionSpecificHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.number_of_valid_points_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.number_of_valid_points_ = from._impl_.number_of_valid_points_;
  // @@protoc_insertion_point(copy_constructor:osi3.CameraDetectionSpecificHeader)
}

inline void CameraDetectionSpecificHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.number_of_valid_points_){0u}
  };
}

CameraDetectionSpecificHeader::~CameraDetectionSpecificHeader() {
  // @@protoc_insertion_point(destructor:osi3.CameraDetectionSpecificHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CameraDetectionSpecificHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CameraDetectionSpecificHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CameraDetectionSpecificHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraDetectionSpecificHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.number_of_valid_points_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CameraDetectionSpecificHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 number_of_valid_points = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_number_of_valid_points(&has_bits);
          _impl_.number_of_valid_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CameraDetectionSpecificHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraDetectionSpecificHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 number_of_valid_points = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_number_of_valid_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraDetectionSpecificHeader)
  return target;
}

size_t CameraDetectionSpecificHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.CameraDetectionSpecificHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 number_of_valid_points = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_valid_points());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CameraDetectionSpecificHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CameraDetectionSpecificHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CameraDetectionSpecificHeader::GetClassData() const { return &_class_data_; }


void CameraDetectionSpecificHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CameraDetectionSpecificHeader*>(&to_msg);
  auto& from = static_cast<const CameraDetectionSpecificHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraDetectionSpecificHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_number_of_valid_points()) {
    _this->_internal_set_number_of_valid_points(from._internal_number_of_valid_points());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CameraDetectionSpecificHeader::CopyFrom(const CameraDetectionSpecificHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraDetectionSpecificHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraDetectionSpecificHeader::IsInitialized() const {
  return true;
}

void CameraDetectionSpecificHeader::InternalSwap(CameraDetectionSpecificHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.number_of_valid_points_, other->_impl_.number_of_valid_points_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraDetectionSpecificHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[10]);
}

// ===================================================================

class CameraDetectionData::_Internal {
 public:
  using HasBits = decltype(std::declval<CameraDetectionData>()._impl_._has_bits_);
  static const ::osi3::SensorDetectionHeader& header(const CameraDetectionData* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::CameraDetectionSpecificHeader& specific_header(const CameraDetectionData* msg);
  static void set_has_specific_header(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::osi3::SensorDetectionHeader&
CameraDetectionData::_Internal::header(const CameraDetectionData* msg) {
  return *msg->_impl_.header_;
}
const ::osi3::CameraDetectionSpecificHeader&
CameraDetectionData::_Internal::specific_header(const CameraDetectionData* msg) {
  return *msg->_impl_.specific_header_;
}
CameraDetectionData::CameraDetectionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.CameraDetectionData)
}
CameraDetectionData::CameraDetectionData(const CameraDetectionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CameraDetectionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.detection_){from._impl_.detection_}
    , decltype(_impl_.point_){from._impl_.point_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.specific_header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::osi3::SensorDetectionHeader(*from._impl_.header_);
  }
  if (from._internal_has_specific_header()) {
    _this->_impl_.specific_header_ = new ::osi3::CameraDetectionSpecificHeader(*from._impl_.specific_header_);
  }
  // @@protoc_insertion_point(copy_constructor:osi3.CameraDetectionData)
}

inline void CameraDetectionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.detection_){arena}
    , decltype(_impl_.point_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.specific_header_){nullptr}
  };
}

CameraDetectionData::~CameraDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.CameraDetectionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CameraDetectionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.detection_.~RepeatedPtrField();
  _impl_.point_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.specific_header_;
}

void CameraDetectionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CameraDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraDetectionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detection_.Clear();
  _impl_.point_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.specific_header_ != nullptr);
      _impl_.specific_header_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CameraDetectionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.SensorDetectionHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.CameraDetection detection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_detection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_specific_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.CameraPoint point = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_point(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CameraDetectionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraDetectionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.SensorDetectionHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .osi3.CameraDetection detection = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_detection_size()); i < n; i++) {
    const auto& repfield = this->_internal_detection(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::specific_header(this),
        _Internal::specific_header(this).GetCachedSize(), target, stream);
  }

  // repeated .osi3.CameraPoint point = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_point_size()); i < n; i++) {
    const auto& repfield = this->_internal_point(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraDetectionData)
  return target;
}

size_t CameraDetectionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.CameraDetectionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.CameraDetection detection = 2;
  total_size += 1UL * this->_internal_detection_size();
  for (const auto& msg : this->_impl_.detection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .osi3.CameraPoint point = 4;
  total_size += 1UL * this->_internal_point_size();
  for (const auto& msg : this->_impl_.point_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .osi3.SensorDetectionHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.specific_header_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CameraDetectionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CameraDetectionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CameraDetectionData::GetClassData() const { return &_class_data_; }


void CameraDetectionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CameraDetectionData*>(&to_msg);
  auto& from = static_cast<const CameraDetectionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraDetectionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.detection_.MergeFrom(from._impl_.detection_);
  _this->_impl_.point_.MergeFrom(from._impl_.point_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header()->::osi3::SensorDetectionHeader::MergeFrom(
          from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_specific_header()->::osi3::CameraDetectionSpecificHeader::MergeFrom(
          from._internal_specific_header());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CameraDetectionData::CopyFrom(const CameraDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraDetectionData::IsInitialized() const {
  return true;
}

void CameraDetectionData::InternalSwap(CameraDetectionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.detection_.InternalSwap(&other->_impl_.detection_);
  _impl_.point_.InternalSwap(&other->_impl_.point_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.specific_header_)
      + sizeof(CameraDetectionData::_impl_.specific_header_)
      - PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraDetectionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[11]);
}

// ===================================================================

class CameraDetection::_Internal {
 public:
  using HasBits = decltype(std::declval<CameraDetection>()._impl_._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::osi3::Identifier& object_id(const CameraDetection* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Timestamp& time_difference(const CameraDetection* msg);
  static void set_has_time_difference(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_image_shape_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_shape_classification_background(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_shape_classification_foreground(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_shape_classification_flat(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_shape_classification_upright(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_shape_classification_ground(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_shape_classification_sky(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_shape_classification_vegetation(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_shape_classification_road(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_shape_classification_non_driving_lane(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_shape_classification_non_road(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_shape_classification_stationary_object(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_shape_classification_moving_object(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_shape_classification_landmark(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_shape_classification_traffic_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_shape_classification_traffic_light(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_shape_classification_road_marking(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_shape_classification_vehicle(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_shape_classification_pedestrian(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_shape_classification_animal(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_shape_classification_pedestrian_front(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_shape_classification_pedestrian_side(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_shape_classification_pedestrian_rear(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_shape_classification_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_color_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::osi3::Identifier& ambiguity_id(const CameraDetection* msg);
  static void set_has_ambiguity_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_first_point_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_number_of_points(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::osi3::ColorDescription& color_description(const CameraDetection* msg);
  static void set_has_color_description(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::osi3::Identifier&
CameraDetection::_Internal::object_id(const CameraDetection* msg) {
  return *msg->_impl_.object_id_;
}
const ::osi3::Timestamp&
CameraDetection::_Internal::time_difference(const CameraDetection* msg) {
  return *msg->_impl_.time_difference_;
}
const ::osi3::Identifier&
CameraDetection::_Internal::ambiguity_id(const CameraDetection* msg) {
  return *msg->_impl_.ambiguity_id_;
}
const ::osi3::ColorDescription&
CameraDetection::_Internal::color_description(const CameraDetection* msg) {
  return *msg->_impl_.color_description_;
}
void CameraDetection::clear_object_id() {
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CameraDetection::clear_time_difference() {
  if (_impl_.time_difference_ != nullptr) _impl_.time_difference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CameraDetection::clear_ambiguity_id() {
  if (_impl_.ambiguity_id_ != nullptr) _impl_.ambiguity_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CameraDetection::clear_color_description() {
  if (_impl_.color_description_ != nullptr) _impl_.color_description_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CameraDetection::CameraDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.CameraDetection)
}
CameraDetection::CameraDetection(const CameraDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CameraDetection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_id_){nullptr}
    , decltype(_impl_.time_difference_){nullptr}
    , decltype(_impl_.ambiguity_id_){nullptr}
    , decltype(_impl_.color_description_){nullptr}
    , decltype(_impl_.existence_probability_){}
    , decltype(_impl_.image_shape_type_){}
    , decltype(_impl_.shape_classification_background_){}
    , decltype(_impl_.shape_classification_foreground_){}
    , decltype(_impl_.shape_classification_flat_){}
    , decltype(_impl_.shape_classification_upright_){}
    , decltype(_impl_.shape_classification_ground_){}
    , decltype(_impl_.shape_classification_sky_){}
    , decltype(_impl_.shape_classification_vegetation_){}
    , decltype(_impl_.shape_classification_road_){}
    , decltype(_impl_.shape_classification_non_driving_lane_){}
    , decltype(_impl_.shape_classification_non_road_){}
    , decltype(_impl_.shape_classification_stationary_object_){}
    , decltype(_impl_.shape_classification_moving_object_){}
    , decltype(_impl_.shape_classification_landmark_){}
    , decltype(_impl_.shape_classification_traffic_sign_){}
    , decltype(_impl_.shape_classification_traffic_light_){}
    , decltype(_impl_.shape_classification_road_marking_){}
    , decltype(_impl_.shape_classification_vehicle_){}
    , decltype(_impl_.shape_classification_pedestrian_){}
    , decltype(_impl_.shape_classification_animal_){}
    , decltype(_impl_.shape_classification_pedestrian_front_){}
    , decltype(_impl_.shape_classification_pedestrian_side_){}
    , decltype(_impl_.shape_classification_pedestrian_rear_){}
    , decltype(_impl_.color_){}
    , decltype(_impl_.shape_classification_probability_){}
    , decltype(_impl_.color_probability_){}
    , decltype(_impl_.first_point_index_){}
    , decltype(_impl_.number_of_points_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_object_id()) {
    _this->_impl_.object_id_ = new ::osi3::Identifier(*from._impl_.object_id_);
  }
  if (from._internal_has_time_difference()) {
    _this->_impl_.time_difference_ = new ::osi3::Timestamp(*from._impl_.time_difference_);
  }
  if (from._internal_has_ambiguity_id()) {
    _this->_impl_.ambiguity_id_ = new ::osi3::Identifier(*from._impl_.ambiguity_id_);
  }
  if (from._internal_has_color_description()) {
    _this->_impl_.color_description_ = new ::osi3::ColorDescription(*from._impl_.color_description_);
  }
  ::memcpy(&_impl_.existence_probability_, &from._impl_.existence_probability_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.number_of_points_) -
    reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.number_of_points_));
  // @@protoc_insertion_point(copy_constructor:osi3.CameraDetection)
}

inline void CameraDetection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_id_){nullptr}
    , decltype(_impl_.time_difference_){nullptr}
    , decltype(_impl_.ambiguity_id_){nullptr}
    , decltype(_impl_.color_description_){nullptr}
    , decltype(_impl_.existence_probability_){0}
    , decltype(_impl_.image_shape_type_){0}
    , decltype(_impl_.shape_classification_background_){false}
    , decltype(_impl_.shape_classification_foreground_){false}
    , decltype(_impl_.shape_classification_flat_){false}
    , decltype(_impl_.shape_classification_upright_){false}
    , decltype(_impl_.shape_classification_ground_){false}
    , decltype(_impl_.shape_classification_sky_){false}
    , decltype(_impl_.shape_classification_vegetation_){false}
    , decltype(_impl_.shape_classification_road_){false}
    , decltype(_impl_.shape_classification_non_driving_lane_){false}
    , decltype(_impl_.shape_classification_non_road_){false}
    , decltype(_impl_.shape_classification_stationary_object_){false}
    , decltype(_impl_.shape_classification_moving_object_){false}
    , decltype(_impl_.shape_classification_landmark_){false}
    , decltype(_impl_.shape_classification_traffic_sign_){false}
    , decltype(_impl_.shape_classification_traffic_light_){false}
    , decltype(_impl_.shape_classification_road_marking_){false}
    , decltype(_impl_.shape_classification_vehicle_){false}
    , decltype(_impl_.shape_classification_pedestrian_){false}
    , decltype(_impl_.shape_classification_animal_){false}
    , decltype(_impl_.shape_classification_pedestrian_front_){false}
    , decltype(_impl_.shape_classification_pedestrian_side_){false}
    , decltype(_impl_.shape_classification_pedestrian_rear_){false}
    , decltype(_impl_.color_){0}
    , decltype(_impl_.shape_classification_probability_){0}
    , decltype(_impl_.color_probability_){0}
    , decltype(_impl_.first_point_index_){0u}
    , decltype(_impl_.number_of_points_){0u}
  };
}

CameraDetection::~CameraDetection() {
  // @@protoc_insertion_point(destructor:osi3.CameraDetection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CameraDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.object_id_;
  if (this != internal_default_instance()) delete _impl_.time_difference_;
  if (this != internal_default_instance()) delete _impl_.ambiguity_id_;
  if (this != internal_default_instance()) delete _impl_.color_description_;
}

void CameraDetection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CameraDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraDetection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.object_id_ != nullptr);
      _impl_.object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.time_difference_ != nullptr);
      _impl_.time_difference_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.ambiguity_id_ != nullptr);
      _impl_.ambiguity_id_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.color_description_ != nullptr);
      _impl_.color_description_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.existence_probability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shape_classification_foreground_) -
        reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.shape_classification_foreground_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.shape_classification_flat_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shape_classification_non_road_) -
        reinterpret_cast<char*>(&_impl_.shape_classification_flat_)) + sizeof(_impl_.shape_classification_non_road_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.shape_classification_stationary_object_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shape_classification_pedestrian_) -
        reinterpret_cast<char*>(&_impl_.shape_classification_stationary_object_)) + sizeof(_impl_.shape_classification_pedestrian_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.shape_classification_animal_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.first_point_index_) -
        reinterpret_cast<char*>(&_impl_.shape_classification_animal_)) + sizeof(_impl_.first_point_index_));
  }
  _impl_.number_of_points_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CameraDetection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_existence_probability(&_impl_._has_bits_);
          _impl_.existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier object_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Timestamp time_difference = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_time_difference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::CameraDetection_ImageShapeType_IsValid(val))) {
            _internal_set_image_shape_type(static_cast<::osi3::CameraDetection_ImageShapeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_background = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_shape_classification_background(&_impl_._has_bits_);
          _impl_.shape_classification_background_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_foreground = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_shape_classification_foreground(&_impl_._has_bits_);
          _impl_.shape_classification_foreground_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_flat = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_shape_classification_flat(&_impl_._has_bits_);
          _impl_.shape_classification_flat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_upright = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_shape_classification_upright(&_impl_._has_bits_);
          _impl_.shape_classification_upright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_ground = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_shape_classification_ground(&_impl_._has_bits_);
          _impl_.shape_classification_ground_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_sky = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_shape_classification_sky(&_impl_._has_bits_);
          _impl_.shape_classification_sky_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_vegetation = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_shape_classification_vegetation(&_impl_._has_bits_);
          _impl_.shape_classification_vegetation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_road = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_shape_classification_road(&_impl_._has_bits_);
          _impl_.shape_classification_road_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_non_driving_lane = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_shape_classification_non_driving_lane(&_impl_._has_bits_);
          _impl_.shape_classification_non_driving_lane_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_non_road = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_shape_classification_non_road(&_impl_._has_bits_);
          _impl_.shape_classification_non_road_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_stationary_object = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_shape_classification_stationary_object(&_impl_._has_bits_);
          _impl_.shape_classification_stationary_object_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_moving_object = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_shape_classification_moving_object(&_impl_._has_bits_);
          _impl_.shape_classification_moving_object_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_landmark = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_shape_classification_landmark(&_impl_._has_bits_);
          _impl_.shape_classification_landmark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_traffic_sign = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_shape_classification_traffic_sign(&_impl_._has_bits_);
          _impl_.shape_classification_traffic_sign_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_traffic_light = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_shape_classification_traffic_light(&_impl_._has_bits_);
          _impl_.shape_classification_traffic_light_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_road_marking = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_shape_classification_road_marking(&_impl_._has_bits_);
          _impl_.shape_classification_road_marking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_vehicle = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_shape_classification_vehicle(&_impl_._has_bits_);
          _impl_.shape_classification_vehicle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_pedestrian = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_shape_classification_pedestrian(&_impl_._has_bits_);
          _impl_.shape_classification_pedestrian_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_animal = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_shape_classification_animal(&_impl_._has_bits_);
          _impl_.shape_classification_animal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_pedestrian_front = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_shape_classification_pedestrian_front(&_impl_._has_bits_);
          _impl_.shape_classification_pedestrian_front_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_pedestrian_side = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_shape_classification_pedestrian_side(&_impl_._has_bits_);
          _impl_.shape_classification_pedestrian_side_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_pedestrian_rear = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_shape_classification_pedestrian_rear(&_impl_._has_bits_);
          _impl_.shape_classification_pedestrian_rear_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double shape_classification_probability = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 217)) {
          _Internal::set_has_shape_classification_probability(&_impl_._has_bits_);
          _impl_.shape_classification_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.CameraDetection.Color color = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::CameraDetection_Color_IsValid(val))) {
            _internal_set_color(static_cast<::osi3::CameraDetection_Color>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(28, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double color_probability = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 233)) {
          _Internal::set_has_color_probability(&_impl_._has_bits_);
          _impl_.color_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier ambiguity_id = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_ambiguity_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 first_point_index = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_first_point_index(&_impl_._has_bits_);
          _impl_.first_point_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_points = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_number_of_points(&_impl_._has_bits_);
          _impl_.number_of_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.ColorDescription color_description = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color_description(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CameraDetection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraDetection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::object_id(this),
        _Internal::object_id(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Timestamp time_difference = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::time_difference(this),
        _Internal::time_difference(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_image_shape_type(), target);
  }

  // optional bool shape_classification_background = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_shape_classification_background(), target);
  }

  // optional bool shape_classification_foreground = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_shape_classification_foreground(), target);
  }

  // optional bool shape_classification_flat = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_shape_classification_flat(), target);
  }

  // optional bool shape_classification_upright = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_shape_classification_upright(), target);
  }

  // optional bool shape_classification_ground = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_shape_classification_ground(), target);
  }

  // optional bool shape_classification_sky = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_shape_classification_sky(), target);
  }

  // optional bool shape_classification_vegetation = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_shape_classification_vegetation(), target);
  }

  // optional bool shape_classification_road = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_shape_classification_road(), target);
  }

  // optional bool shape_classification_non_driving_lane = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_shape_classification_non_driving_lane(), target);
  }

  // optional bool shape_classification_non_road = 14;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_shape_classification_non_road(), target);
  }

  // optional bool shape_classification_stationary_object = 15;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_shape_classification_stationary_object(), target);
  }

  // optional bool shape_classification_moving_object = 16;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_shape_classification_moving_object(), target);
  }

  // optional bool shape_classification_landmark = 17;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_shape_classification_landmark(), target);
  }

  // optional bool shape_classification_traffic_sign = 18;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_shape_classification_traffic_sign(), target);
  }

  // optional bool shape_classification_traffic_light = 19;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_shape_classification_traffic_light(), target);
  }

  // optional bool shape_classification_road_marking = 20;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_shape_classification_road_marking(), target);
  }

  // optional bool shape_classification_vehicle = 21;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_shape_classification_vehicle(), target);
  }

  // optional bool shape_classification_pedestrian = 22;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_shape_classification_pedestrian(), target);
  }

  // optional bool shape_classification_animal = 23;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_shape_classification_animal(), target);
  }

  // optional bool shape_classification_pedestrian_front = 24;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_shape_classification_pedestrian_front(), target);
  }

  // optional bool shape_classification_pedestrian_side = 25;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_shape_classification_pedestrian_side(), target);
  }

  // optional bool shape_classification_pedestrian_rear = 26;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_shape_classification_pedestrian_rear(), target);
  }

  // optional double shape_classification_probability = 27;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(27, this->_internal_shape_classification_probability(), target);
  }

  // optional .osi3.CameraDetection.Color color = 28;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      28, this->_internal_color(), target);
  }

  // optional double color_probability = 29;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(29, this->_internal_color_probability(), target);
  }

  // optional .osi3.Identifier ambiguity_id = 30;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::ambiguity_id(this),
        _Internal::ambiguity_id(this).GetCachedSize(), target, stream);
  }

  // optional uint32 first_point_index = 31;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_first_point_index(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 number_of_points = 32;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(32, this->_internal_number_of_points(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .osi3.ColorDescription color_description = 33;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::color_description(this),
        _Internal::color_description(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraDetection)
  return target;
}

size_t CameraDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.CameraDetection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .osi3.Identifier object_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_id_);
    }

    // optional .osi3.Timestamp time_difference = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_difference_);
    }

    // optional .osi3.Identifier ambiguity_id = 30;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ambiguity_id_);
    }

    // optional .osi3.ColorDescription color_description = 33;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_description_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_image_shape_type());
    }

    // optional bool shape_classification_background = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_foreground = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool shape_classification_flat = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_upright = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_ground = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_sky = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_vegetation = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_road = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_non_driving_lane = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_non_road = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool shape_classification_stationary_object = 15;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_moving_object = 16;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_landmark = 17;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_traffic_sign = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_traffic_light = 19;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_road_marking = 20;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_vehicle = 21;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_pedestrian = 22;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool shape_classification_animal = 23;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_pedestrian_front = 24;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_pedestrian_side = 25;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_pedestrian_rear = 26;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional .osi3.CameraDetection.Color color = 28;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_color());
    }

    // optional double shape_classification_probability = 27;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 8;
    }

    // optional double color_probability = 29;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 8;
    }

    // optional uint32 first_point_index = 31;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_first_point_index());
    }

  }
  // optional uint32 number_of_points = 32;
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_number_of_points());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CameraDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CameraDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CameraDetection::GetClassData() const { return &_class_data_; }


void CameraDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CameraDetection*>(&to_msg);
  auto& from = static_cast<const CameraDetection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraDetection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_object_id()->::osi3::Identifier::MergeFrom(
          from._internal_object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_time_difference()->::osi3::Timestamp::MergeFrom(
          from._internal_time_difference());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_ambiguity_id()->::osi3::Identifier::MergeFrom(
          from._internal_ambiguity_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_color_description()->::osi3::ColorDescription::MergeFrom(
          from._internal_color_description());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.image_shape_type_ = from._impl_.image_shape_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.shape_classification_background_ = from._impl_.shape_classification_background_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.shape_classification_foreground_ = from._impl_.shape_classification_foreground_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.shape_classification_flat_ = from._impl_.shape_classification_flat_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.shape_classification_upright_ = from._impl_.shape_classification_upright_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.shape_classification_ground_ = from._impl_.shape_classification_ground_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.shape_classification_sky_ = from._impl_.shape_classification_sky_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.shape_classification_vegetation_ = from._impl_.shape_classification_vegetation_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.shape_classification_road_ = from._impl_.shape_classification_road_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.shape_classification_non_driving_lane_ = from._impl_.shape_classification_non_driving_lane_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.shape_classification_non_road_ = from._impl_.shape_classification_non_road_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.shape_classification_stationary_object_ = from._impl_.shape_classification_stationary_object_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.shape_classification_moving_object_ = from._impl_.shape_classification_moving_object_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.shape_classification_landmark_ = from._impl_.shape_classification_landmark_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.shape_classification_traffic_sign_ = from._impl_.shape_classification_traffic_sign_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.shape_classification_traffic_light_ = from._impl_.shape_classification_traffic_light_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.shape_classification_road_marking_ = from._impl_.shape_classification_road_marking_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.shape_classification_vehicle_ = from._impl_.shape_classification_vehicle_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.shape_classification_pedestrian_ = from._impl_.shape_classification_pedestrian_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.shape_classification_animal_ = from._impl_.shape_classification_animal_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.shape_classification_pedestrian_front_ = from._impl_.shape_classification_pedestrian_front_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.shape_classification_pedestrian_side_ = from._impl_.shape_classification_pedestrian_side_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.shape_classification_pedestrian_rear_ = from._impl_.shape_classification_pedestrian_rear_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.shape_classification_probability_ = from._impl_.shape_classification_probability_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.color_probability_ = from._impl_.color_probability_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.first_point_index_ = from._impl_.first_point_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_has_number_of_points()) {
    _this->_internal_set_number_of_points(from._internal_number_of_points());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CameraDetection::CopyFrom(const CameraDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraDetection::IsInitialized() const {
  return true;
}

void CameraDetection::InternalSwap(CameraDetection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.number_of_points_)
      + sizeof(CameraDetection::_impl_.number_of_points_)
      - PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.object_id_)>(
          reinterpret_cast<char*>(&_impl_.object_id_),
          reinterpret_cast<char*>(&other->_impl_.object_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraDetection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[12]);
}

// ===================================================================

class CameraPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<CameraPoint>()._impl_._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::osi3::Spherical3d& point(const CameraPoint* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Spherical3d& point_rmse(const CameraPoint* msg);
  static void set_has_point_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::osi3::Spherical3d&
CameraPoint::_Internal::point(const CameraPoint* msg) {
  return *msg->_impl_.point_;
}
const ::osi3::Spherical3d&
CameraPoint::_Internal::point_rmse(const CameraPoint* msg) {
  return *msg->_impl_.point_rmse_;
}
void CameraPoint::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CameraPoint::clear_point_rmse() {
  if (_impl_.point_rmse_ != nullptr) _impl_.point_rmse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CameraPoint::CameraPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:osi3.CameraPoint)
}
CameraPoint::CameraPoint(const CameraPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CameraPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.point_rmse_){nullptr}
    , decltype(_impl_.existence_probability_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_point()) {
    _this->_impl_.point_ = new ::osi3::Spherical3d(*from._impl_.point_);
  }
  if (from._internal_has_point_rmse()) {
    _this->_impl_.point_rmse_ = new ::osi3::Spherical3d(*from._impl_.point_rmse_);
  }
  _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
  // @@protoc_insertion_point(copy_constructor:osi3.CameraPoint)
}

inline void CameraPoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.point_rmse_){nullptr}
    , decltype(_impl_.existence_probability_){0}
  };
}

CameraPoint::~CameraPoint() {
  // @@protoc_insertion_point(destructor:osi3.CameraPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CameraPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
  if (this != internal_default_instance()) delete _impl_.point_rmse_;
}

void CameraPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CameraPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.point_ != nullptr);
      _impl_.point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.point_rmse_ != nullptr);
      _impl_.point_rmse_->Clear();
    }
  }
  _impl_.existence_probability_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CameraPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_existence_probability(&has_bits);
          _impl_.existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d point_rmse = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_rmse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CameraPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Spherical3d point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // optional .osi3.Spherical3d point_rmse = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::point_rmse(this),
        _Internal::point_rmse(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraPoint)
  return target;
}

size_t CameraPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.CameraPoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .osi3.Spherical3d point = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point_);
    }

    // optional .osi3.Spherical3d point_rmse = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point_rmse_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CameraPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CameraPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CameraPoint::GetClassData() const { return &_class_data_; }


void CameraPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CameraPoint*>(&to_msg);
  auto& from = static_cast<const CameraPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraPoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point()->::osi3::Spherical3d::MergeFrom(
          from._internal_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_point_rmse()->::osi3::Spherical3d::MergeFrom(
          from._internal_point_rmse());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CameraPoint::CopyFrom(const CameraPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraPoint::IsInitialized() const {
  return true;
}

void CameraPoint::InternalSwap(CameraPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_.existence_probability_)
      + sizeof(CameraPoint::_impl_.existence_probability_)
      - PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace osi3
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::osi3::FeatureData*
Arena::CreateMaybeMessage< ::osi3::FeatureData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::FeatureData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::SensorDetectionHeader*
Arena::CreateMaybeMessage< ::osi3::SensorDetectionHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::SensorDetectionHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::RadarDetectionData*
Arena::CreateMaybeMessage< ::osi3::RadarDetectionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::RadarDetectionData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::RadarDetection*
Arena::CreateMaybeMessage< ::osi3::RadarDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::RadarDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::LidarDetectionData*
Arena::CreateMaybeMessage< ::osi3::LidarDetectionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::LidarDetectionData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::LidarDetection*
Arena::CreateMaybeMessage< ::osi3::LidarDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::LidarDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::UltrasonicDetectionSpecificHeader*
Arena::CreateMaybeMessage< ::osi3::UltrasonicDetectionSpecificHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::UltrasonicDetectionSpecificHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::UltrasonicDetectionData*
Arena::CreateMaybeMessage< ::osi3::UltrasonicDetectionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::UltrasonicDetectionData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::UltrasonicDetection*
Arena::CreateMaybeMessage< ::osi3::UltrasonicDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::UltrasonicDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::UltrasonicIndirectDetection*
Arena::CreateMaybeMessage< ::osi3::UltrasonicIndirectDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::UltrasonicIndirectDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::CameraDetectionSpecificHeader*
Arena::CreateMaybeMessage< ::osi3::CameraDetectionSpecificHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::CameraDetectionSpecificHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::CameraDetectionData*
Arena::CreateMaybeMessage< ::osi3::CameraDetectionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::CameraDetectionData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::CameraDetection*
Arena::CreateMaybeMessage< ::osi3::CameraDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::CameraDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::CameraPoint*
Arena::CreateMaybeMessage< ::osi3::CameraPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::CameraPoint >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
